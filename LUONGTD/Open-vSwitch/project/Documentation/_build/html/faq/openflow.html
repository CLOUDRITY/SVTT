
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Using OpenFlow &#8212; Open vSwitch 2.9.2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quality of Service (QoS)" href="qos.html" />
    <link rel="prev" title="Common Configuration Issues" href="issues.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="using-openflow">
<h1>Using OpenFlow<a class="headerlink" href="#using-openflow" title="Permalink to this headline">¶</a></h1>
<p>Q: What versions of OpenFlow does Open vSwitch support?</p>
<blockquote>
<div><p>A: The following table lists the versions of OpenFlow supported by each
version of Open vSwitch:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Open vSwitch</th>
<th class="head">OF1.0</th>
<th class="head">OF1.1</th>
<th class="head">OF1.2</th>
<th class="head">OF1.3</th>
<th class="head">OF1.4</th>
<th class="head">OF1.5</th>
<th class="head">OF1.6</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1.9 and earlier</td>
<td>yes</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr class="row-odd"><td>1.10, 1.11</td>
<td>yes</td>
<td>—</td>
<td>(*)</td>
<td>(*)</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr class="row-even"><td>2.0, 2.1</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
<td>—</td>
<td>—</td>
<td>—</td>
</tr>
<tr class="row-odd"><td>2.2</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
<td>(%)</td>
<td>(*)</td>
<td>—</td>
</tr>
<tr class="row-even"><td>2.3, 2.4</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>—</td>
</tr>
<tr class="row-odd"><td>2.5, 2.6, 2.7</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
<td>(*)</td>
</tr>
<tr class="row-even"><td>2.8</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>(*)</td>
<td>(*)</td>
</tr>
</tbody>
</table>
<p class="attribution">&mdash;Not supported.
yes Supported and enabled by default
(*) Supported, but missing features, and must be enabled by user.
(%) Experimental, unsafe implementation.</p>
</div></blockquote>
<blockquote>
<div><p>In any case, the user may override the default:</p>
<ul>
<li><p class="first">To enable OpenFlow 1.0, 1.1, 1.2, and 1.3 on bridge br0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set bridge br0 \
    protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13
</pre></div>
</div>
</li>
<li><p class="first">To enable OpenFlow 1.0, 1.1, 1.2, 1.3, 1.4, and 1.5 on bridge br0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set bridge br0 \
    protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13,OpenFlow14,OpenFlow15
</pre></div>
</div>
</li>
<li><p class="first">To enable only OpenFlow 1.0 on bridge br0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set bridge br0 protocols=OpenFlow10
</pre></div>
</div>
</li>
</ul>
<p>All current versions of ovs-ofctl enable only OpenFlow 1.0 by default.  Use
the -O option to enable support for later versions of OpenFlow in
ovs-ofctl.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl -O OpenFlow13 dump-flows br0
</pre></div>
</div>
<p>(Open vSwitch 2.2 had an experimental implementation of OpenFlow 1.4 that
could cause crashes.  We don’t recommend enabling it.)</p>
<p><a class="reference internal" href="../topics/openflow.html"><span class="doc">OpenFlow Support in Open vSwitch</span></a> tracks support for OpenFlow 1.1 and later features.
When support for OpenFlow 1.5 and 1.6 is solidly implemented, Open vSwitch
will enable those version by default.</p>
</div></blockquote>
<p>Q: Does Open vSwitch support MPLS?</p>
<blockquote>
<div><p>A: Before version 1.11, Open vSwitch did not support MPLS.  That is, these
versions can match on MPLS Ethernet types, but they cannot match, push, or
pop MPLS labels, nor can they look past MPLS labels into the encapsulated
packet.</p>
<p>Open vSwitch versions 1.11, 2.0, and 2.1 have very minimal support for
MPLS.  With the userspace datapath only, these versions can match, push, or
pop a single MPLS label, but they still cannot look past MPLS labels (even
after popping them) into the encapsulated packet.  Kernel datapath support
is unchanged from earlier versions.</p>
<p>Open vSwitch version 2.3 can match, push, or pop a single MPLS label and
look past the MPLS label into the encapsulated packet.  Both userspace and
kernel datapaths will be supported, but MPLS processing always happens in
userspace either way, so kernel datapath performance will be disappointing.</p>
<p>Open vSwitch version 2.4 can match, push, or pop up to 3 MPLS labels and
look past the MPLS label into the encapsulated packet.  It will have kernel
support for MPLS, yielding improved performance.</p>
</div></blockquote>
<p>Q: I’m getting “error type 45250 code 0”.  What’s that?</p>
<blockquote>
<div><p>A: This is a Open vSwitch extension to OpenFlow error codes.  Open vSwitch
uses this extension when it must report an error to an OpenFlow controller
but no standard OpenFlow error code is suitable.</p>
<p>Open vSwitch logs the errors that it sends to controllers, so the easiest
thing to do is probably to look at the ovs-vswitchd log to find out what
the error was.</p>
<p>If you want to dissect the extended error message yourself, the format is
documented in include/openflow/nicira-ext.h in the Open vSwitch source
distribution.  The extended error codes are documented in
include/openvswitch/ofp-errors.h.</p>
</div></blockquote>
<p>Q: Some of the traffic that I’d expect my OpenFlow controller to see doesn’t
actually appear through the OpenFlow connection, even though I know that it’s
going through.</p>
<blockquote>
<div><p>A: By default, Open vSwitch assumes that OpenFlow controllers are connected
“in-band”, that is, that the controllers are actually part of the network
that is being controlled.  In in-band mode, Open vSwitch sets up special
“hidden” flows to make sure that traffic can make it back and forth between
OVS and the controllers.  These hidden flows are higher priority than any
flows that can be set up through OpenFlow, and they are not visible through
normal OpenFlow flow table dumps.</p>
<p>Usually, the hidden flows are desirable and helpful, but occasionally they
can cause unexpected behavior.  You can view the full OpenFlow flow table,
including hidden flows, on bridge br0 with the command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl bridge/dump-flows br0
</pre></div>
</div>
<p>to help you debug.  The hidden flows are those with priorities
greater than 65535 (the maximum priority that can be set with
OpenFlow).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Documentation/topics/design</span></code> doc describes the in-band model in
detail.</p>
<p>If your controllers are not actually in-band (e.g. they are on
localhost via 127.0.0.1, or on a separate network), then you should
configure your controllers in “out-of-band” mode.  If you have one
controller on bridge br0, then you can configure out-of-band mode
on it with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set controller br0 connection-mode=out-of-band
</pre></div>
</div>
</div></blockquote>
<p>Q: Some of the OpenFlow flows that my controller sets up don’t seem to apply to
certain traffic, especially traffic between OVS and the controller itself.</p>
<blockquote>
<div>A: See above.</div></blockquote>
<p>Q: I configured all my controllers for out-of-band control mode but “ovs-appctl
bridge/dump-flows” still shows some hidden flows.</p>
<blockquote>
<div><p>A: You probably have a remote manager configured (e.g. with “ovs-vsctl
set-manager”).  By default, Open vSwitch assumes that managers need in-band
rules set up on every bridge.  You can disable these rules on bridge br0
with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set bridge br0 other-config:disable-in-band=true
</pre></div>
</div>
<p>This actually disables in-band control entirely for the bridge, as if all
the bridge’s controllers were configured for out-of-band control.</p>
</div></blockquote>
<p>Q: My OpenFlow controller doesn’t see the VLANs that I expect.</p>
<blockquote>
<div>A: See answer under “VLANs”, above.</div></blockquote>
<p>Q: I ran <code class="docutils literal notranslate"><span class="pre">ovs-ofctl</span> <span class="pre">add-flow</span> <span class="pre">br0</span> <span class="pre">nw_dst=192.168.0.1,actions=drop</span></code> but I got a
funny message like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ofp_util</span><span class="o">|</span><span class="n">INFO</span><span class="o">|</span><span class="n">normalization</span> <span class="n">changed</span> <span class="n">ofp_match</span><span class="p">,</span> <span class="n">details</span><span class="p">:</span>
<span class="n">ofp_util</span><span class="o">|</span><span class="n">INFO</span><span class="o">|</span> <span class="n">pre</span><span class="p">:</span> <span class="n">nw_dst</span><span class="o">=</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">0.1</span>
<span class="n">ofp_util</span><span class="o">|</span><span class="n">INFO</span><span class="o">|</span><span class="n">post</span><span class="p">:</span>
</pre></div>
</div>
<p>and when I ran <code class="docutils literal notranslate"><span class="pre">ovs-ofctl</span> <span class="pre">dump-flows</span> <span class="pre">br0</span></code> I saw that my nw_dst match had
disappeared, so that the flow ends up matching every packet.</p>
<blockquote>
<div><p>A: The term “normalization” in the log message means that a flow cannot
match on an L3 field without saying what L3 protocol is in use.  The
“ovs-ofctl” command above didn’t specify an L3 protocol, so the L3 field
match was dropped.</p>
<p>In this case, the L3 protocol could be IP or ARP.  A correct command for
each possibility is, respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 ip,nw_dst=192.168.0.1,actions=drop
</pre></div>
</div>
<p>and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 arp,nw_dst=192.168.0.1,actions=drop
</pre></div>
</div>
<p>Similarly, a flow cannot match on an L4 field without saying what L4
protocol is in use.  For example, the flow match <code class="docutils literal notranslate"><span class="pre">tp_src=1234</span></code> is, by
itself, meaningless and will be ignored.  Instead, to match TCP source port
1234, write <code class="docutils literal notranslate"><span class="pre">tcp,tp_src=1234</span></code>, or to match UDP source port 1234, write
<code class="docutils literal notranslate"><span class="pre">udp,tp_src=1234</span></code>.</p>
</div></blockquote>
<p>Q: How can I figure out the OpenFlow port number for a given port?</p>
<blockquote>
<div><p>A: The <code class="docutils literal notranslate"><span class="pre">OFPT_FEATURES_REQUEST</span></code> message requests an OpenFlow switch to
respond with an <code class="docutils literal notranslate"><span class="pre">OFPT_FEATURES_REPLY</span></code> that, among other information,
includes a mapping between OpenFlow port names and numbers.  From a command
prompt, <code class="docutils literal notranslate"><span class="pre">ovs-ofctl</span> <span class="pre">show</span> <span class="pre">br0</span></code> makes such a request and prints the response
for switch br0.</p>
<p>The Interface table in the Open vSwitch database also maps OpenFlow port
names to numbers.  To print the OpenFlow port number associated with
interface eth0, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl get Interface eth0 ofport
</pre></div>
</div>
<p>You can print the entire mapping with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl -- --columns=name,ofport list Interface
</pre></div>
</div>
<p>but the output mixes together interfaces from all bridges in the database,
so it may be confusing if more than one bridge exists.</p>
<p>In the Open vSwitch database, ofport value <code class="docutils literal notranslate"><span class="pre">-1</span></code> means that the interface
could not be created due to an error.  (The Open vSwitch log should
indicate the reason.)  ofport value <code class="docutils literal notranslate"><span class="pre">[]</span></code> (the empty set) means that the
interface hasn’t been created yet.  The latter is normally an intermittent
condition (unless ovs-vswitchd is not running).</p>
</div></blockquote>
<p>Q: I added some flows with my controller or with ovs-ofctl, but when I run
“ovs-dpctl dump-flows” I don’t see them.</p>
<blockquote>
<div>A: ovs-dpctl queries a kernel datapath, not an OpenFlow switch.  It won’t
display the information that you want.  You want to use <code class="docutils literal notranslate"><span class="pre">ovs-ofctl</span>
<span class="pre">dump-flows</span></code> instead.</div></blockquote>
<p>Q: It looks like each of the interfaces in my bonded port shows up as an
individual OpenFlow port.  Is that right?</p>
<blockquote>
<div><p>A: Yes, Open vSwitch makes individual bond interfaces visible as OpenFlow
ports, rather than the bond as a whole.  The interfaces are treated
together as a bond for only a few purposes:</p>
<ul class="simple">
<li>Sending a packet to the OFPP_NORMAL port.  (When an OpenFlow controller
is not configured, this happens implicitly to every packet.)</li>
<li>Mirrors configured for output to a bonded port.</li>
</ul>
<p>It would make a lot of sense for Open vSwitch to present a bond as a single
OpenFlow port.  If you want to contribute an implementation of such a
feature, please bring it up on the Open vSwitch development mailing list at
<a class="reference external" href="mailto:dev&#37;&#52;&#48;openvswitch&#46;org">dev<span>&#64;</span>openvswitch<span>&#46;</span>org</a>.</p>
</div></blockquote>
<p>Q: I have a sophisticated network setup involving Open vSwitch, VMs or multiple
hosts, and other components.  The behavior isn’t what I expect.  Help!</p>
<blockquote>
<div><p>A: To debug network behavior problems, trace the path of a packet,
hop-by-hop, from its origin in one host to a remote host.  If that’s
correct, then trace the path of the response packet back to the origin.</p>
<p>The open source tool called <code class="docutils literal notranslate"><span class="pre">plotnetcfg</span></code> can help to understand the
relationship between the networking devices on a single host.</p>
<p>Usually a simple ICMP echo request and reply (<code class="docutils literal notranslate"><span class="pre">ping</span></code>) packet is good
enough.  Start by initiating an ongoing <code class="docutils literal notranslate"><span class="pre">ping</span></code> from the origin host to a
remote host.  If you are tracking down a connectivity problem, the “ping”
will not display any successful output, but packets are still being sent.
(In this case the packets being sent are likely ARP rather than ICMP.)</p>
<p>Tools available for tracing include the following:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> and <code class="docutils literal notranslate"><span class="pre">wireshark</span></code> for observing hops across network devices,
such as Open vSwitch internal devices and physical wires.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ovs-appctl</span> <span class="pre">dpif/dump-flows</span> <span class="pre">&lt;br&gt;</span></code> in Open vSwitch 1.10 and later or
<code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span> <span class="pre">&lt;br&gt;</span></code> in earlier versions.  These tools allow one
to observe the actions being taken on packets in ongoing flows.</p>
<p>See ovs-vswitchd(8) for <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span> <span class="pre">dpif/dump-flows</span></code> documentation,
ovs-dpctl(8) for <code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></code> documentation, and “Why are
there so many different ways to dump flows?” above for some background.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">ovs-appctl</span> <span class="pre">ofproto/trace</span></code> to observe the logic behind how ovs-vswitchd
treats packets.  See ovs-vswitchd(8) for documentation.  You can out more
details about a given flow that <code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></code> displays, by
cutting and pasting a flow from the output into an <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span>
<span class="pre">ofproto/trace</span></code> command.</p>
</li>
<li><p class="first">SPAN, RSPAN, and ERSPAN features of physical switches, to observe what
goes on at these physical hops.</p>
</li>
</ul>
<p>Starting at the origin of a given packet, observe the packet at each hop in
turn.  For example, in one plausible scenario, you might:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> the <code class="docutils literal notranslate"><span class="pre">eth</span></code> interface through which an ARP egresses a VM,
from inside the VM.</li>
<li><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> the <code class="docutils literal notranslate"><span class="pre">vif</span></code> or <code class="docutils literal notranslate"><span class="pre">tap</span></code> interface through which the ARP
ingresses the host machine.</li>
<li>Use <code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></code> to spot the ARP flow and observe the host
interface through which the ARP egresses the physical machine.  You may
need to use <code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">show</span></code> to interpret the port numbers.  If the
output seems surprising, you can use <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span> <span class="pre">ofproto/trace</span></code> to
observe details of how ovs-vswitchd determined the actions in the
<code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></code> output.</li>
<li><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> the <code class="docutils literal notranslate"><span class="pre">eth</span></code> interface through which the ARP egresses the
physical machine.</li>
<li><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> the <code class="docutils literal notranslate"><span class="pre">eth</span></code> interface through which the ARP ingresses the
physical machine, at the remote host that receives the ARP.</li>
<li>Use <code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">dump-flows</span></code> to spot the ARP flow on the remote host
remote host that receives the ARP and observe the VM <code class="docutils literal notranslate"><span class="pre">vif</span></code> or <code class="docutils literal notranslate"><span class="pre">tap</span></code>
interface to which the flow is directed.  Again, <code class="docutils literal notranslate"><span class="pre">ovs-dpctl</span> <span class="pre">show</span></code> and
<code class="docutils literal notranslate"><span class="pre">ovs-appctl</span> <span class="pre">ofproto/trace</span></code> might help.</li>
<li><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> the <code class="docutils literal notranslate"><span class="pre">vif</span></code> or <code class="docutils literal notranslate"><span class="pre">tap</span></code> interface to which the ARP is
directed.</li>
<li><code class="docutils literal notranslate"><span class="pre">tcpdump</span></code> the <code class="docutils literal notranslate"><span class="pre">eth</span></code> interface through which the ARP ingresses a VM,
from inside the VM.</li>
</ol>
<p>It is likely that during one of these steps you will figure out the
problem.  If not, then follow the ARP reply back to the origin, in reverse.</p>
</div></blockquote>
<p>Q: How do I make a flow drop packets?</p>
<blockquote>
<div><p>A: To drop a packet is to receive it without forwarding it.  OpenFlow
explicitly specifies forwarding actions.  Thus, a flow with an empty set of
actions does not forward packets anywhere, causing them to be dropped.  You
can specify an empty set of actions with <code class="docutils literal notranslate"><span class="pre">actions=</span></code> on the ovs-ofctl
command line.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 priority=65535,actions=
</pre></div>
</div>
<p>would cause every packet entering switch br0 to be dropped.</p>
<p>You can write “drop” explicitly if you like.  The effect is the same.
Thus, the following command also causes every packet entering switch br0 to
be dropped:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 priority=65535,actions=drop
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">drop</span></code> is not an action, either in OpenFlow or Open vSwitch.  Rather, it
is only a way to say that there are no actions.</p>
</div></blockquote>
<p>Q: I added a flow to send packets out the ingress port, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 in_port=2,actions=2
</pre></div>
</div>
<p>but OVS drops the packets instead.</p>
<blockquote>
<div><p>A: Yes, OpenFlow requires a switch to ignore attempts to send a packet out
its ingress port.  The rationale is that dropping these packets makes it
harder to loop the network.  Sometimes this behavior can even be
convenient, e.g. it is often the desired behavior in a flow that forwards a
packet to several ports (“floods” the packet).</p>
<p>Sometimes one really needs to send a packet out its ingress port
(“hairpin”). In this case, output to <code class="docutils literal notranslate"><span class="pre">OFPP_IN_PORT</span></code>, which in ovs-ofctl
syntax is expressed as just <code class="docutils literal notranslate"><span class="pre">in_port</span></code>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 in_port=2,actions=in_port
</pre></div>
</div>
<p>This also works in some circumstances where the flow doesn’t match on the
input port.  For example, if you know that your switch has five ports
numbered 2 through 6, then the following will send every received packet
out every port, even its ingress port:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 actions=2,3,4,5,6,in_port
</pre></div>
</div>
<p>or, equivalently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 actions=all,in_port
</pre></div>
</div>
<p>Sometimes, in complicated flow tables with multiple levels of <code class="docutils literal notranslate"><span class="pre">resubmit</span></code>
actions, a flow needs to output to a particular port that may or may not be
the ingress port.  It’s difficult to take advantage of <code class="docutils literal notranslate"><span class="pre">OFPP_IN_PORT</span></code> in
this situation.  To help, Open vSwitch provides, as an OpenFlow extension,
the ability to modify the in_port field.  Whatever value is currently in
the in_port field is the port to which outputs will be dropped, as well as
the destination for <code class="docutils literal notranslate"><span class="pre">OFPP_IN_PORT</span></code>.  This means that the following will
reliably output to port 2 or to ports 2 through 6, respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 in_port=2,actions=load:0-&gt;NXM_OF_IN_PORT[],2
$ ovs-ofctl add-flow br0 actions=load:0-&gt;NXM_OF_IN_PORT[],2,3,4,5,6
</pre></div>
</div>
<p>If the input port is important, then one may save and restore it on the
stack:</p>
<blockquote>
<div><dl class="docutils">
<dt>$ ovs-ofctl add-flow br0 actions=push:NXM_OF_IN_PORT[],</dt>
<dd>load:0-&gt;NXM_OF_IN_PORT[],2,3,4,5,6,pop:NXM_OF_IN_PORT[]</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>Q: My bridge br0 has host 192.168.0.1 on port 1 and host 192.168.0.2 on port 2.
I set up flows to forward only traffic destined to the other host and drop
other traffic, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="n">nw_dst</span><span class="o">=</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">0.2</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">2</span>
<span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="n">nw_dst</span><span class="o">=</span><span class="mf">192.168</span><span class="o">.</span><span class="mf">0.1</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">1</span>
<span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="n">drop</span>
</pre></div>
</div>
<p>But it doesn’t work–I don’t get any connectivity when I do this.  Why?</p>
<blockquote>
<div><p>A: These flows drop the ARP packets that IP hosts use to establish IP
connectivity over Ethernet.  To solve the problem, add flows to allow ARP
to pass between the hosts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">arp</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">2</span>
<span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">arp</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>This issue can manifest other ways, too.  The following flows that match on
Ethernet addresses instead of IP addresses will also drop ARP packets,
because ARP requests are broadcast instead of being directed to a specific
host:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dl_dst</span><span class="o">=</span><span class="mi">54</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">02</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">2</span>
<span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">dl_dst</span><span class="o">=</span><span class="mi">54</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">01</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">1</span>
<span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="n">drop</span>
</pre></div>
</div>
<p>The solution already described above will also work in this case.  It may
be better to add flows to allow all multicast and broadcast traffic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dl_dst</span><span class="o">=</span><span class="mi">01</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="o">/</span><span class="mi">01</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">2</span>
<span class="n">priority</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">in_port</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">dl_dst</span><span class="o">=</span><span class="mi">01</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="o">/</span><span class="mi">01</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">,</span><span class="n">actions</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
</div></blockquote>
<p>Q: My bridge disconnects from my controller on add-port/del-port.</p>
<blockquote>
<div><p>A: Reconfiguring your bridge can change your bridge’s datapath-id because
Open vSwitch generates datapath-id from the MAC address of one of its
ports.  In that case, Open vSwitch disconnects from controllers because
there’s no graceful way to notify controllers about the change of
datapath-id.</p>
<p>To avoid the behaviour, you can configure datapath-id manually.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set bridge br0 other-config:datapath-id=0123456789abcdef
</pre></div>
</div>
</div></blockquote>
<p>Q: My controller complains that OVS is not buffering packets.
What’s going on?</p>
<blockquote>
<div><p>A: “Packet buffering” is an optional OpenFlow feature, and controllers
should detect how many “buffers” an OpenFlow switch implements.  It was
recently noticed that OVS implementation of the buffering feature was not
compliant to OpenFlow specifications.  Rather than fix it and risk
controller incompatibility, the buffering feature is removed as of OVS 2.7.
Controllers are already expected to work properly in cases where the switch
can not buffer packets, but sends full packets in “packet-in” messages
instead, so this change should not affect existing users.  After the change
OVS always sends the <code class="docutils literal notranslate"><span class="pre">buffer_id</span></code> as <code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code> in “packet-in”
messages and will send an error response if any other value of this field
is included in a “packet-out” or a “flow mod” sent by a controller.</p>
<p>Packet buffers have limited usefulness in any case.  Table-miss packet-in
messages most commonly pass the first packet in a microflow to the OpenFlow
controller, which then sets up an OpenFlow flow that handles remaining
traffic in the microflow without further controller intervention.  In such
a case, the packet that initiates the microflow is in practice usually
small (certainly for TCP), which means that the switch sends the entire
packet to the controller and the buffer only saves a small number of bytes
in the reverse direction.</p>
</div></blockquote>
<p>Q: How does OVS divide flows among buckets in an OpenFlow “select” group?</p>
<blockquote>
<div><p>A: In Open vSwitch 2.3 and earlier, Open vSwitch used the destination
Ethernet address to choose a bucket in a select group.</p>
<p>Open vSwitch 2.4 and later by default hashes the source and destination
Ethernet address, VLAN ID, Ethernet type, IPv4/v6 source and destination
address and protocol, and for TCP and SCTP only, the source and destination
ports.  The hash is “symmetric”, meaning that exchanging source and
destination addresses does not change the bucket selection.</p>
<p>Select groups in Open vSwitch 2.4 and later can be configured to use a
different hash function, using a Netronome extension to the OpenFlow 1.5+
group_mod message.  For more information, see
Documentation/group-selection-method-property.txt in the Open vSwitch
source tree.  (OpenFlow 1.5 support in Open vSwitch is still experimental.)</p>
</div></blockquote>
<p>Q: I added a flow to accept packets on VLAN 123 and output them on VLAN 456,
like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 dl_vlan=123,actions=output:1,mod_vlan_vid:456
</pre></div>
</div>
<p>but the packets are actually being output in VLAN 123.  Why?</p>
<blockquote>
<div><p>A: OpenFlow actions are executed in the order specified.  Thus, the actions
above first output the packet, then change its VLAN.  Since the output
occurs before changing the VLAN, the change in VLAN will have no visible
effect.</p>
<p>To solve this and similar problems, order actions so that changes to
headers happen before output, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 dl_vlan=123,actions=mod_vlan_vid:456,output:1
</pre></div>
</div>
<p>See also the following question.</p>
</div></blockquote>
<p>Q: I added a flow to a redirect packets for TCP port 80 to port 443,
like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 tcp,tcp_dst=123,actions=mod_tp_dst:443
</pre></div>
</div>
<p>but the packets are getting dropped instead.  Why?</p>
<blockquote>
<div><p>A: This set of actions does change the TCP destination port to 443, but
then it does nothing more.  It doesn’t, for example, say to continue to
another flow table or to output the packet.  Therefore, the packet is
dropped.</p>
<p>To solve the problem, add an action that does something with the modified
packet.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl add-flow br0 tcp,tcp_dst=123,actions=mod_tp_dst:443,normal
</pre></div>
</div>
<p>See also the preceding question.</p>
</div></blockquote>
<p>Q: The “learn” action can’t learn the action I want, can you improve it?</p>
<blockquote>
<div><p>A: By itself, the “learn” action can only put two kinds of actions into the
flows that it creates: “load” and “output” actions.  If “learn” is used in
isolation, these are severe limits.</p>
<p>However, “learn” is not meant to be used in isolation.  It is a primitive
meant to be used together with other Open vSwitch features to accomplish a
task.  Its existing features are enough to accomplish most tasks.</p>
<p>Here is an outline of a typical pipeline structure that allows for
versatile behavior using “learn”:</p>
<ul class="simple">
<li>Flows in table A contain a “learn” action, that populates flows in table
L, that use a “load” action to populate register R with information about
what was learned.</li>
<li>Flows in table B contain two sequential resubmit actions: one to table L
and another one to table B+1.</li>
<li>Flows in table B+1 match on register R and act differently depending on
what the flows in table L loaded into it.</li>
</ul>
<p>This approach can be used to implement many “learn”-based features.  For
example:</p>
<ul class="simple">
<li>Resubmit to a table selected based on learned information, e.g. see:
<a class="reference external" href="https://mail.openvswitch.org/pipermail/ovs-discuss/2016-June/021694.html">https://mail.openvswitch.org/pipermail/ovs-discuss/2016-June/021694.html</a></li>
<li>MAC learning in the middle of a pipeline, as described in
<a class="reference internal" href="../tutorials/ovs-advanced.html"><span class="doc">Open vSwitch Advanced Features</span></a></li>
<li>TCP state based firewalling, by learning outgoing connections based on
SYN packets and matching them up with incoming packets.</li>
<li>At least some of the features described in T. A. Hoff, “Extending Open
vSwitch to Facilitate Creation of Stateful SDN Applications”.</li>
</ul>
</div></blockquote>
<p>Q: When using the “ct” action with FTP connections, it doesn’t seem to matter
if I set the “alg=ftp” parameter in the action. Is this required?</p>
<blockquote>
<div>A: It is advisable to use this option. Some platforms may automatically
detect and apply ALGs in the “ct” action regardless of the parameters you
provide, however this is not consistent across all implementations. The
<a class="reference external" href="http://openvswitch.org/support/dist-docs/ovs-ofctl.8.html">ovs-ofctl(8)</a>
man pages contain further details in the description of the ALG parameter.</div></blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">Open vSwitch FAQ</a><ul>
      <li>Previous: <a href="issues.html" title="previous chapter">Common Configuration Issues</a></li>
      <li>Next: <a href="qos.html" title="next chapter">Quality of Service (QoS)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/faq/openflow.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, The Open vSwitch Development Community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/faq/openflow.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>