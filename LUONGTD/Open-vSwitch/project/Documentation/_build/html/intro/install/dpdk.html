
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Open vSwitch with DPDK &#8212; Open vSwitch 2.9.2 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Distributions packaging Open vSwitch" href="distributions.html" />
    <link rel="prev" title="Open vSwitch without Kernel Support" href="userspace.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="open-vswitch-with-dpdk">
<h1>Open vSwitch with DPDK<a class="headerlink" href="#open-vswitch-with-dpdk" title="Permalink to this headline">¶</a></h1>
<p>This document describes how to build and install Open vSwitch using a DPDK
datapath. Open vSwitch can use the DPDK library to operate entirely in
userspace.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="../../faq/releases.html"><span class="doc">releases FAQ</span></a> lists support for the required
versions of DPDK for each version of Open vSwitch.</p>
</div>
<div class="section" id="build-requirements">
<h2>Build requirements<a class="headerlink" href="#build-requirements" title="Permalink to this headline">¶</a></h2>
<p>In addition to the requirements described in <a class="reference internal" href="general.html"><span class="doc">Open vSwitch on Linux, FreeBSD and NetBSD</span></a>, building Open
vSwitch with DPDK will require the following:</p>
<ul>
<li><p class="first">DPDK 17.11.2</p>
</li>
<li><p class="first">A <a class="reference external" href="http://dpdk.org/doc/nics">DPDK supported NIC</a></p>
<p>Only required when physical ports are in use</p>
</li>
<li><p class="first">A suitable kernel</p>
<p>On Linux Distros running kernel version &gt;= 3.0, only <cite>IOMMU</cite> needs to enabled
via the grub cmdline, assuming you are using <strong>VFIO</strong>. For older kernels,
ensure the kernel is built with <code class="docutils literal notranslate"><span class="pre">UIO</span></code>, <code class="docutils literal notranslate"><span class="pre">HUGETLBFS</span></code>,
<code class="docutils literal notranslate"><span class="pre">PROC_PAGE_MONITOR</span></code>, <code class="docutils literal notranslate"><span class="pre">HPET</span></code>, <code class="docutils literal notranslate"><span class="pre">HPET_MMAP</span></code> support. If these are not
present, it will be necessary to upgrade your kernel or build a custom kernel
with these flags enabled.</p>
</li>
</ul>
<p>Detailed system requirements can be found at <a class="reference external" href="http://dpdk.org/doc/guides/linux_gsg/sys_reqs.html">DPDK requirements</a>.</p>
</div>
<div class="section" id="installing">
<h2>Installing<a class="headerlink" href="#installing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="install-dpdk">
<h3>Install DPDK<a class="headerlink" href="#install-dpdk" title="Permalink to this headline">¶</a></h3>
<ol class="arabic">
<li><p class="first">Download the <a class="reference external" href="http://dpdk.org/rel">DPDK sources</a>, extract the file and set <code class="docutils literal notranslate"><span class="pre">DPDK_DIR</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd /usr/src/
$ wget http://fast.dpdk.org/rel/dpdk-17.11.2.tar.xz
$ tar xf dpdk-17.11.2.tar.xz
$ export DPDK_DIR=/usr/src/dpdk-stable-17.11.2
$ cd $DPDK_DIR
</pre></div>
</div>
</li>
<li><p class="first">(Optional) Configure DPDK as a shared library</p>
<p>DPDK can be built as either a static library or a shared library.  By
default, it is configured for the former. If you wish to use the latter, set
<code class="docutils literal notranslate"><span class="pre">CONFIG_RTE_BUILD_SHARED_LIB=y</span></code> in <code class="docutils literal notranslate"><span class="pre">$DPDK_DIR/config/common_base</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Minor performance loss is expected when using OVS with a shared DPDK
library compared to a static DPDK library.</p>
</div>
</li>
<li><p class="first">Configure and install DPDK</p>
<p>Build and install the DPDK library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export DPDK_TARGET=x86_64-native-linuxapp-gcc
$ export DPDK_BUILD=$DPDK_DIR/$DPDK_TARGET
$ make install T=$DPDK_TARGET DESTDIR=install
</pre></div>
</div>
</li>
<li><p class="first">(Optional) Export the DPDK shared library location</p>
<p>If DPDK was built as a shared library, export the path to this library for
use when building OVS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export LD_LIBRARY_PATH=$DPDK_DIR/x86_64-native-linuxapp-gcc/lib
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="install-ovs">
<h3>Install OVS<a class="headerlink" href="#install-ovs" title="Permalink to this headline">¶</a></h3>
<p>OVS can be installed using different methods. For OVS to use DPDK datapath, it
has to be configured with DPDK support (<code class="docutils literal notranslate"><span class="pre">--with-dpdk</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section focuses on generic recipe that suits most cases. For
distribution specific instructions, refer to one of the more relevant guides.</p>
</div>
<ol class="arabic">
<li><p class="first">Ensure the standard OVS requirements, described in
<a class="reference internal" href="general.html#general-build-reqs"><span class="std std-ref">Build Requirements</span></a>, are installed</p>
</li>
<li><p class="first">Bootstrap, if required, as described in <a class="reference internal" href="general.html#general-bootstrapping"><span class="std std-ref">Bootstrapping</span></a></p>
</li>
<li><p class="first">Configure the package using the <code class="docutils literal notranslate"><span class="pre">--with-dpdk</span></code> flag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./configure --with-dpdk=$DPDK_BUILD
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">DPDK_BUILD</span></code> is the path to the built DPDK library. This can be
skipped if DPDK library is installed in its default location.</p>
<p>If no path is provided to <code class="docutils literal notranslate"><span class="pre">--with-dpdk</span></code>, but a pkg-config configuration
for libdpdk is available the include paths will be generated via an
equivalent <code class="docutils literal notranslate"><span class="pre">pkg-config</span> <span class="pre">--cflags</span> <span class="pre">libdpdk</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While <code class="docutils literal notranslate"><span class="pre">--with-dpdk</span></code> is required, you can pass any other configuration
option described in <a class="reference internal" href="general.html#general-configuring"><span class="std std-ref">Configuring</span></a>.</p>
</div>
</li>
<li><p class="first">Build and install OVS, as described in <a class="reference internal" href="general.html#general-building"><span class="std std-ref">Building</span></a></p>
</li>
</ol>
<p>Additional information can be found in <a class="reference internal" href="general.html"><span class="doc">Open vSwitch on Linux, FreeBSD and NetBSD</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are running using the Fedora or Red Hat package, the Open vSwitch
daemon will run as a non-root user.  This implies that you must have a
working IOMMU.  Visit the <a class="reference external" href="https://github.com/openvswitch/ovs/blob/master/rhel/README.RHEL.rst">RHEL README</a> for additional information.</p>
</div>
</div>
</div>
<div class="section" id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setup-hugepages">
<h3>Setup Hugepages<a class="headerlink" href="#setup-hugepages" title="Permalink to this headline">¶</a></h3>
<p>Allocate a number of 2M Huge pages:</p>
<ul>
<li><p class="first">For persistent allocation of huge pages, write to hugepages.conf file
in <cite>/etc/sysctl.d</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ echo &#39;vm.nr_hugepages=2048&#39; &gt; /etc/sysctl.d/hugepages.conf
</pre></div>
</div>
</li>
<li><p class="first">For run-time allocation of huge pages, use the <code class="docutils literal notranslate"><span class="pre">sysctl</span></code> utility:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sysctl -w vm.nr_hugepages=N  # where N = No. of 2M huge pages
</pre></div>
</div>
</li>
</ul>
<p>To verify hugepage configuration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ grep HugePages_ /proc/meminfo
</pre></div>
</div>
<p>Mount the hugepages, if not already mounted by default:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mount -t hugetlbfs none /dev/hugepages``
</pre></div>
</div>
</div>
<div class="section" id="setup-dpdk-devices-using-vfio">
<span id="dpdk-vfio"></span><h3>Setup DPDK devices using VFIO<a class="headerlink" href="#setup-dpdk-devices-using-vfio" title="Permalink to this headline">¶</a></h3>
<p>VFIO is prefered to the UIO driver when using recent versions of DPDK. VFIO
support required support from both the kernel and BIOS. For the former, kernel
version &gt; 3.6 must be used. For the latter, you must enable VT-d in the BIOS
and ensure this is configured via grub. To ensure VT-d is enabled via the BIOS,
run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ dmesg | grep -e DMAR -e IOMMU
</pre></div>
</div>
<p>If VT-d is not enabled in the BIOS, enable it now.</p>
<p>To ensure VT-d is enabled in the kernel, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat /proc/cmdline | grep iommu=pt
$ cat /proc/cmdline | grep intel_iommu=on
</pre></div>
</div>
<p>If VT-d is not enabled in the kernel, enable it now.</p>
<p>Once VT-d is correctly configured, load the required modules and bind the NIC
to the VFIO driver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ modprobe vfio-pci
$ /usr/bin/chmod a+x /dev/vfio
$ /usr/bin/chmod 0666 /dev/vfio/*
$ $DPDK_DIR/usertools/dpdk-devbind.py --bind=vfio-pci eth1
$ $DPDK_DIR/usertools/dpdk-devbind.py --status
</pre></div>
</div>
</div>
<div class="section" id="setup-ovs">
<h3>Setup OVS<a class="headerlink" href="#setup-ovs" title="Permalink to this headline">¶</a></h3>
<p>Open vSwitch should be started as described in <a class="reference internal" href="general.html"><span class="doc">Open vSwitch on Linux, FreeBSD and NetBSD</span></a> with the
exception of ovs-vswitchd, which requires some special configuration to enable
DPDK functionality. DPDK configuration arguments can be passed to ovs-vswitchd
via the <code class="docutils literal notranslate"><span class="pre">other_config</span></code> column of the <code class="docutils literal notranslate"><span class="pre">Open_vSwitch</span></code> table. At a minimum,
the <code class="docutils literal notranslate"><span class="pre">dpdk-init</span></code> option must be set to <code class="docutils literal notranslate"><span class="pre">true</span></code>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export PATH=$PATH:/usr/local/share/openvswitch/scripts
$ export DB_SOCK=/usr/local/var/run/openvswitch/db.sock
$ ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=true
$ ovs-ctl --no-ovsdb-server --db-sock=&quot;$DB_SOCK&quot; start
</pre></div>
</div>
<p>There are many other configuration options, the most important of which are
listed below. Defaults will be provided for all values not explicitly set.</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">dpdk-init</span></code></dt>
<dd>Specifies whether OVS should initialize and support DPDK ports. This is a
boolean, and defaults to false.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpdk-lcore-mask</span></code></dt>
<dd>Specifies the CPU cores on which dpdk lcore threads should be spawned and
expects hex string (eg ‘0x123’).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpdk-socket-mem</span></code></dt>
<dd>Comma separated list of memory to pre-allocate from hugepages on specific
sockets.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dpdk-hugepage-dir</span></code></dt>
<dd>Directory where hugetlbfs is mounted</dd>
<dt><code class="docutils literal notranslate"><span class="pre">vhost-sock-dir</span></code></dt>
<dd>Option to set the path to the vhost-user unix socket files.</dd>
</dl>
<p>If allocating more than one GB hugepage, you can configure the
amount of memory used from any given NUMA nodes. For example, to use 1GB from
NUMA node 0 and 0GB for all other NUMA nodes, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl --no-wait set Open_vSwitch . \
    other_config:dpdk-socket-mem=&quot;1024,0&quot;
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl --no-wait set Open_vSwitch . \
    other_config:dpdk-socket-mem=&quot;1024&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Changing any of these options requires restarting the ovs-vswitchd
application</p>
</div>
<p>See the section <code class="docutils literal notranslate"><span class="pre">Performance</span> <span class="pre">Tuning</span></code> for important DPDK customizations.</p>
</div>
</div>
<div class="section" id="validating">
<h2>Validating<a class="headerlink" href="#validating" title="Permalink to this headline">¶</a></h2>
<p>At this point you can use ovs-vsctl to set up bridges and other Open vSwitch
features. Seeing as we’ve configured the DPDK datapath, we will use DPDK-type
ports. For example, to create a userspace bridge named <code class="docutils literal notranslate"><span class="pre">br0</span></code> and add two
<code class="docutils literal notranslate"><span class="pre">dpdk</span></code> ports to it, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev
$ ovs-vsctl add-port br0 myportnameone -- set Interface myportnameone \
    type=dpdk options:dpdk-devargs=0000:06:00.0
$ ovs-vsctl add-port br0 myportnametwo -- set Interface myportnametwo \
    type=dpdk options:dpdk-devargs=0000:06:00.1
</pre></div>
</div>
<p>DPDK devices will not be available for use until a valid dpdk-devargs is
specified.</p>
<p>Refer to ovs-vsctl(8) and <a class="reference internal" href="../../howto/dpdk.html"><span class="doc">Using Open vSwitch with DPDK</span></a> for more details.</p>
</div>
<div class="section" id="performance-tuning">
<h2>Performance Tuning<a class="headerlink" href="#performance-tuning" title="Permalink to this headline">¶</a></h2>
<p>To achieve optimal OVS performance, the system can be configured and that
includes BIOS tweaks, Grub cmdline additions, better understanding of NUMA
nodes and apt selection of PCIe slots for NIC placement.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section is optional. Once installed as described above, OVS with DPDK
will work out of the box.</p>
</div>
<div class="section" id="recommended-bios-settings">
<h3>Recommended BIOS Settings<a class="headerlink" href="#recommended-bios-settings" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">Recommended BIOS Settings</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Setting</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>C3 Power State</td>
<td>Disabled</td>
</tr>
<tr class="row-odd"><td>C6 Power State</td>
<td>Disabled</td>
</tr>
<tr class="row-even"><td>MLC Streamer</td>
<td>Enabled</td>
</tr>
<tr class="row-odd"><td>MLC Spacial Prefetcher</td>
<td>Enabled</td>
</tr>
<tr class="row-even"><td>DCU Data Prefetcher</td>
<td>Enabled</td>
</tr>
<tr class="row-odd"><td>DCA</td>
<td>Enabled</td>
</tr>
<tr class="row-even"><td>CPU Power and Performance</td>
<td>Performance</td>
</tr>
<tr class="row-odd"><td>Memeory RAS and Performance Config -&gt; NUMA optimized</td>
<td>Enabled</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pcie-slot-selection">
<h3>PCIe Slot Selection<a class="headerlink" href="#pcie-slot-selection" title="Permalink to this headline">¶</a></h3>
<p>The fastpath performance can be affected by factors related to the placement of
the NIC, such as channel speeds between PCIe slot and CPU or the proximity of
PCIe slot to the CPU cores running the DPDK application. Listed below are the
steps to identify right PCIe slot.</p>
<ol class="arabic">
<li><p class="first">Retrieve host details using <code class="docutils literal notranslate"><span class="pre">dmidecode</span></code>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ dmidecode -t baseboard | grep &quot;Product Name&quot;
</pre></div>
</div>
</li>
<li><p class="first">Download the technical specification for product listed, e.g: S2600WT2</p>
</li>
<li><p class="first">Check the Product Architecture Overview on the Riser slot placement, CPU
sharing info and also PCIe channel speeds</p>
<p>For example: On S2600WT, CPU1 and CPU2 share Riser Slot 1 with Channel speed
between CPU1 and Riser Slot1 at 32GB/s, CPU2 and Riser Slot1 at 16GB/s.
Running DPDK app on CPU1 cores and NIC inserted in to Riser card Slots will
optimize OVS performance in this case.</p>
</li>
<li><p class="first">Check the Riser Card #1 - Root Port mapping information, on the available
slots and individual bus speeds. In S2600WT slot 1, slot 2 has high bus
speeds and are potential slots for NIC placement.</p>
</li>
</ol>
</div>
<div class="section" id="advanced-hugepage-setup">
<h3>Advanced Hugepage Setup<a class="headerlink" href="#advanced-hugepage-setup" title="Permalink to this headline">¶</a></h3>
<p>Allocate and mount 1 GB hugepages.</p>
<ul>
<li><p class="first">For persistent allocation of huge pages, add the following options to the
kernel bootline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">default_hugepagesz</span><span class="o">=</span><span class="mi">1</span><span class="n">GB</span> <span class="n">hugepagesz</span><span class="o">=</span><span class="mi">1</span><span class="n">G</span> <span class="n">hugepages</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>For platforms supporting multiple huge page sizes, add multiple options:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">default_hugepagesz</span><span class="o">=&lt;</span><span class="n">size</span><span class="o">&gt;</span> <span class="n">hugepagesz</span><span class="o">=&lt;</span><span class="n">size</span><span class="o">&gt;</span> <span class="n">hugepages</span><span class="o">=</span><span class="n">N</span>
</pre></div>
</div>
<p>where:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt>
<dd><p class="first last">number of huge pages requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt>
<dd><p class="first last">huge page size with an optional suffix <code class="docutils literal notranslate"><span class="pre">[kKmMgG]</span></code></p>
</dd>
</dl>
</li>
<li><p class="first">For run-time allocation of huge pages:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ echo N &gt; /sys/devices/system/node/nodeX/hugepages/hugepages-1048576kB/nr_hugepages
</pre></div>
</div>
<p>where:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt>
<dd><p class="first last">number of huge pages requested</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X</span></code></dt>
<dd><p class="first last">NUMA Node</p>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For run-time allocation of 1G huge pages, Contiguous Memory Allocator
(<code class="docutils literal notranslate"><span class="pre">CONFIG_CMA</span></code>) has to be supported by kernel, check your Linux distro.</p>
</div>
</li>
</ul>
<p>Now mount the huge pages, if not already done so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mount -t hugetlbfs -o pagesize=1G none /dev/hugepages
</pre></div>
</div>
</div>
<div class="section" id="isolate-cores">
<h3>Isolate Cores<a class="headerlink" href="#isolate-cores" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">isolcpus</span></code> option can be used to isolate cores from the Linux scheduler.
The isolated cores can then be used to dedicatedly run HPC applications or
threads.  This helps in better application performance due to zero context
switching and minimal cache thrashing. To run platform logic on core 0 and
isolate cores between 1 and 19 from scheduler, add  <code class="docutils literal notranslate"><span class="pre">isolcpus=1-19</span></code> to GRUB
cmdline.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It has been verified that core isolation has minimal advantage due to mature
Linux scheduler in some circumstances.</p>
</div>
</div>
<div class="section" id="compiler-optimizations">
<h3>Compiler Optimizations<a class="headerlink" href="#compiler-optimizations" title="Permalink to this headline">¶</a></h3>
<p>The default compiler optimization level is <code class="docutils literal notranslate"><span class="pre">-O2</span></code>. Changing this to more
aggressive compiler optimization such as <code class="docutils literal notranslate"><span class="pre">-O3</span> <span class="pre">-march=native</span></code> with
gcc (verified on 5.3.1) can produce performance gains though not siginificant.
<code class="docutils literal notranslate"><span class="pre">-march=native</span></code> will produce optimized code on local machine and should be
used when software compilation is done on Testbed.</p>
</div>
<div class="section" id="multiple-poll-mode-driver-threads">
<h3>Multiple Poll-Mode Driver Threads<a class="headerlink" href="#multiple-poll-mode-driver-threads" title="Permalink to this headline">¶</a></h3>
<p>With pmd multi-threading support, OVS creates one pmd thread for each NUMA node
by default, if there is at least one DPDK interface from that NUMA node added
to OVS. However, in cases where there are multiple ports/rxq’s producing
traffic, performance can be improved by creating multiple pmd threads running
on separate cores. These pmd threads can share the workload by each being
responsible for different ports/rxq’s. Assignment of ports/rxq’s to pmd threads
is done automatically.</p>
<p>A set bit in the mask means a pmd thread is created and pinned to the
corresponding CPU core. For example, to run pmd threads on core 1 and 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=0x6
</pre></div>
</div>
<p>When using dpdk and dpdkvhostuser ports in a bi-directional VM loopback as
shown below, spreading the workload over 2 or 4 pmd threads shows significant
improvements as there will be more total CPU occupancy available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NIC</span> <span class="n">port0</span> <span class="o">&lt;-&gt;</span> <span class="n">OVS</span> <span class="o">&lt;-&gt;</span> <span class="n">VM</span> <span class="o">&lt;-&gt;</span> <span class="n">OVS</span> <span class="o">&lt;-&gt;</span> <span class="n">NIC</span> <span class="n">port</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Refer to ovs-vswitchd.conf.db(5) for additional information on configuration
options.</p>
</div>
<div class="section" id="affinity">
<h3>Affinity<a class="headerlink" href="#affinity" title="Permalink to this headline">¶</a></h3>
<p>For superior performance, DPDK pmd threads and Qemu vCPU threads needs to be
affinitized accordingly.</p>
<ul>
<li><p class="first">PMD thread Affinity</p>
<p>A poll mode driver (pmd) thread handles the I/O of all DPDK interfaces
assigned to it. A pmd thread shall poll the ports for incoming packets,
switch the packets and send to tx port.  A pmd thread is CPU bound, and needs
to be affinitized to isolated cores for optimum performance.  Even though a
PMD thread may exist, the thread only starts consuming CPU cycles if there is
at least one receive queue assigned to the pmd.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On NUMA systems, PCI devices are also local to a NUMA node.  Unbound rx
queues for a PCI device will be assigned to a pmd on it’s local NUMA node
if a non-isolated PMD exists on that NUMA node.  If not, the queue will be
assigned to a non-isolated pmd on a remote NUMA node.  This will result in
reduced maximum throughput on that device and possibly on other devices
assigned to that pmd thread. If such a queue assignment is made a warning
message will be logged: “There’s no available (non-isolated) pmd thread on
numa node N. Queue Q on port P will be assigned to the pmd on core C
(numa node N’). Expect reduced performance.”</p>
</div>
<p>Binding PMD threads to cores is described in the above section
<code class="docutils literal notranslate"><span class="pre">Multiple</span> <span class="pre">Poll-Mode</span> <span class="pre">Driver</span> <span class="pre">Threads</span></code>.</p>
</li>
<li><p class="first">QEMU vCPU thread Affinity</p>
<p>A VM performing simple packet forwarding or running complex packet pipelines
has to ensure that the vCPU threads performing the work has as much CPU
occupancy as possible.</p>
<p>For example, on a multicore VM, multiple QEMU vCPU threads shall be spawned.
When the DPDK <code class="docutils literal notranslate"><span class="pre">testpmd</span></code> application that does packet forwarding is invoked,
the <code class="docutils literal notranslate"><span class="pre">taskset</span></code> command should be used to affinitize the vCPU threads to the
dedicated isolated cores on the host system.</p>
</li>
</ul>
</div>
<div class="section" id="enable-hyperthreading">
<h3>Enable HyperThreading<a class="headerlink" href="#enable-hyperthreading" title="Permalink to this headline">¶</a></h3>
<p>With HyperThreading, or SMT, enabled, a physical core appears as two logical
cores. SMT can be utilized to spawn worker threads on logical cores of the same
physical core there by saving additional cores.</p>
<p>With DPDK, when pinning pmd threads to logical cores, care must be taken to set
the correct bits of the <code class="docutils literal notranslate"><span class="pre">pmd-cpu-mask</span></code> to ensure that the pmd threads are
pinned to SMT siblings.</p>
<p>Take a sample system configuration, with 2 sockets, 2 * 10 core processors, HT
enabled. This gives us a total of 40 logical cores. To identify the physical
core shared by two logical cores, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat /sys/devices/system/cpu/cpuN/topology/thread_siblings_list
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the logical core number.</p>
<p>In this example, it would show that cores <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">21</span></code> share the same
physical core. Logical cores can be specified in pmd-cpu-masks similarly to
physical cores, as described in <code class="docutils literal notranslate"><span class="pre">Multiple</span> <span class="pre">Poll-Mode</span> <span class="pre">Driver</span> <span class="pre">Threads</span></code>.</p>
</div>
<div class="section" id="numa-cluster-on-die">
<h3>NUMA/Cluster-on-Die<a class="headerlink" href="#numa-cluster-on-die" title="Permalink to this headline">¶</a></h3>
<p>Ideally inter-NUMA datapaths should be avoided where possible as packets will
go across QPI and there may be a slight performance penalty when compared with
intra NUMA datapaths. On Intel Xeon Processor E5 v3, Cluster On Die is
introduced on models that have 10 cores or more.  This makes it possible to
logically split a socket into two NUMA regions and again it is preferred where
possible to keep critical datapaths within the one cluster.</p>
<p>It is good practice to ensure that threads that are in the datapath are pinned
to cores in the same NUMA area. e.g. pmd threads and QEMU vCPUs responsible for
forwarding. If DPDK is built with <code class="docutils literal notranslate"><span class="pre">CONFIG_RTE_LIBRTE_VHOST_NUMA=y</span></code>, vHost
User ports automatically detect the NUMA socket of the QEMU vCPUs and will be
serviced by a PMD from the same node provided a core on this node is enabled in
the <code class="docutils literal notranslate"><span class="pre">pmd-cpu-mask</span></code>. <code class="docutils literal notranslate"><span class="pre">libnuma</span></code> packages are required for this feature.</p>
<p>Binding PMD threads is described in the above section
<code class="docutils literal notranslate"><span class="pre">Multiple</span> <span class="pre">Poll-Mode</span> <span class="pre">Driver</span> <span class="pre">Threads</span></code>.</p>
</div>
<div class="section" id="dpdk-physical-port-rx-queues">
<h3>DPDK Physical Port Rx Queues<a class="headerlink" href="#dpdk-physical-port-rx-queues" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Interface &lt;DPDK interface&gt; options:n_rxq=&lt;integer&gt;
</pre></div>
</div>
<p>The above command sets the number of rx queues for DPDK physical interface.
The rx queues are assigned to pmd threads on the same NUMA node in a
round-robin fashion.</p>
</div>
<div class="section" id="dpdk-physical-port-queue-sizes">
<span id="dpdk-queues-sizes"></span><h3>DPDK Physical Port Queue Sizes<a class="headerlink" href="#dpdk-physical-port-queue-sizes" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Interface dpdk0 options:n_rxq_desc=&lt;integer&gt;
$ ovs-vsctl set Interface dpdk0 options:n_txq_desc=&lt;integer&gt;
</pre></div>
</div>
<p>The above command sets the number of rx/tx descriptors that the NIC associated
with dpdk0 will be initialised with.</p>
<p>Different <code class="docutils literal notranslate"><span class="pre">n_rxq_desc</span></code> and <code class="docutils literal notranslate"><span class="pre">n_txq_desc</span></code> configurations yield different
benefits in terms of throughput and latency for different scenarios.
Generally, smaller queue sizes can have a positive impact for latency at the
expense of throughput. The opposite is often true for larger queue sizes.
Note: increasing the number of rx descriptors eg. to 4096  may have a negative
impact on performance due to the fact that non-vectorised DPDK rx functions may
be used. This is dependent on the driver in use, but is true for the commonly
used i40e and ixgbe DPDK drivers.</p>
</div>
<div class="section" id="exact-match-cache">
<h3>Exact Match Cache<a class="headerlink" href="#exact-match-cache" title="Permalink to this headline">¶</a></h3>
<p>Each pmd thread contains one Exact Match Cache (EMC). After initial flow setup
in the datapath, the EMC contains a single table and provides the lowest level
(fastest) switching for DPDK ports. If there is a miss in the EMC then the next
level where switching will occur is the datapath classifier.  Missing in the
EMC and looking up in the datapath classifier incurs a significant performance
penalty.  If lookup misses occur in the EMC because it is too small to handle
the number of flows, its size can be increased. The EMC size can be modified by
editing the define <code class="docutils literal notranslate"><span class="pre">EM_FLOW_HASH_SHIFT</span></code> in <code class="docutils literal notranslate"><span class="pre">lib/dpif-netdev.c</span></code>.</p>
<p>As mentioned above, an EMC is per pmd thread. An alternative way of increasing
the aggregate amount of possible flow entries in EMC and avoiding datapath
classifier lookups is to have multiple pmd threads running.</p>
</div>
<div class="section" id="rx-mergeable-buffers">
<h3>Rx Mergeable Buffers<a class="headerlink" href="#rx-mergeable-buffers" title="Permalink to this headline">¶</a></h3>
<p>Rx mergeable buffers is a virtio feature that allows chaining of multiple
virtio descriptors to handle large packet sizes. Large packets are handled by
reserving and chaining multiple free descriptors together. Mergeable buffer
support is negotiated between the virtio driver and virtio device and is
supported by the DPDK vhost library.  This behavior is supported and enabled by
default, however in the case where the user knows that rx mergeable buffers are
not needed i.e. jumbo frames are not needed, it can be forced off by adding
<code class="docutils literal notranslate"><span class="pre">mrg_rxbuf=off</span></code> to the QEMU command line options. By not reserving multiple
chains of descriptors it will make more individual virtio descriptors available
for rx to the guest using dpdkvhost ports and this can improve performance.</p>
</div>
<div class="section" id="output-packet-batching">
<h3>Output Packet Batching<a class="headerlink" href="#output-packet-batching" title="Permalink to this headline">¶</a></h3>
<p>To make advantage of batched transmit functions, OVS collects packets in
intermediate queues before sending when processing a batch of received packets.
Even if packets are matched by different flows, OVS uses a single send
operation for all packets destined to the same output port.</p>
<p>Furthermore, OVS is able to buffer packets in these intermediate queues for a
configurable amount of time to reduce the frequency of send bursts at medium
load levels when the packet receive rate is high, but the receive batch size
still very small. This is particularly beneficial for packets transmitted to
VMs using an interrupt-driven virtio driver, where the interrupt overhead is
significant for the OVS PMD, the host operating system and the guest driver.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">tx-flush-interval</span></code> parameter can be used to specify the time in
microseconds OVS should wait between two send bursts to a given port (default
is <code class="docutils literal notranslate"><span class="pre">0</span></code>). When the intermediate queue fills up before that time is over, the
buffered packet batch is sent immediately:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Open_vSwitch . other_config:tx-flush-interval=50
</pre></div>
</div>
<p>This parameter influences both throughput and latency, depending on the traffic
load on the port. In general lower values decrease latency while higher values
may be useful to achieve higher throughput.</p>
<p>Low traffic (<code class="docutils literal notranslate"><span class="pre">packet</span> <span class="pre">rate</span> <span class="pre">&lt;</span> <span class="pre">1</span> <span class="pre">/</span> <span class="pre">tx-flush-interval</span></code>) should not experience
any significant latency or throughput increase as packets are forwarded
immediately.</p>
<p>At intermediate load levels
(<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">tx-flush-interval</span> <span class="pre">&lt;</span> <span class="pre">packet</span> <span class="pre">rate</span> <span class="pre">&lt;</span> <span class="pre">32</span> <span class="pre">/</span> <span class="pre">tx-flush-interval</span></code>) traffic
should experience an average latency increase of up to
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">tx-flush-interval</span></code> and a possible throughput improvement.</p>
<p>Very high traffic (<code class="docutils literal notranslate"><span class="pre">packet</span> <span class="pre">rate</span> <span class="pre">&gt;&gt;</span> <span class="pre">32</span> <span class="pre">/</span> <span class="pre">tx-flush-interval</span></code>) should experience
the average latency increase equal to <code class="docutils literal notranslate"><span class="pre">32</span> <span class="pre">/</span> <span class="pre">(2</span> <span class="pre">*</span> <span class="pre">packet</span> <span class="pre">rate)</span></code>. Most send
batches in this case will contain the maximum number of packets (<code class="docutils literal notranslate"><span class="pre">32</span></code>).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">tx-burst-interval</span></code> value of <code class="docutils literal notranslate"><span class="pre">50</span></code> microseconds has shown to provide a
good performance increase in a <code class="docutils literal notranslate"><span class="pre">PHY-VM-PHY</span></code> scenario on <code class="docutils literal notranslate"><span class="pre">x86</span></code> system for
interrupt-driven guests while keeping the latency increase at a reasonable
level:</p>
<blockquote>
<div><a class="reference external" href="https://mail.openvswitch.org/pipermail/ovs-dev/2017-December/341628.html">https://mail.openvswitch.org/pipermail/ovs-dev/2017-December/341628.html</a></div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Throughput impact of this option significantly depends on the scenario and
the traffic patterns. For example: <code class="docutils literal notranslate"><span class="pre">tx-burst-interval</span></code> value of <code class="docutils literal notranslate"><span class="pre">50</span></code>
microseconds shows performance degradation in <code class="docutils literal notranslate"><span class="pre">PHY-VM-PHY</span></code> with bonded PHY
scenario while testing with <code class="docutils literal notranslate"><span class="pre">256</span> <span class="pre">-</span> <span class="pre">1024</span></code> packet flows:</p>
<blockquote class="last">
<div><a class="reference external" href="https://mail.openvswitch.org/pipermail/ovs-dev/2017-December/341700.html">https://mail.openvswitch.org/pipermail/ovs-dev/2017-December/341700.html</a></div></blockquote>
</div>
<p>The average number of packets per output batch can be checked in PMD stats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-stats-show
</pre></div>
</div>
</div>
<div class="section" id="link-state-change-lsc-detection-configuration">
<h3>Link State Change (LSC) detection configuration<a class="headerlink" href="#link-state-change-lsc-detection-configuration" title="Permalink to this headline">¶</a></h3>
<p>There are two methods to get the information when Link State Change (LSC)
happens on a network interface: by polling or interrupt.</p>
<p>Configuring the lsc detection mode has no direct effect on OVS itself,
instead it configures the NIC how it should handle link state changes.
Processing the link state update request triggered by OVS takes less time
using interrupt mode, since the NIC updates its link state in the
background, while in polling mode the link state has to be fetched from
the firmware every time to fulfil this request.</p>
<p>Note that not all PMD drivers support LSC interrupts.</p>
<p>The default configuration is polling mode. To set interrupt mode, option
<code class="docutils literal notranslate"><span class="pre">dpdk-lsc-interrupt</span></code> has to be set to <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<dl class="docutils">
<dt>Command to set interrupt mode for a specific interface::</dt>
<dd>$ ovs-vsctl set interface &lt;iface_name&gt; options:dpdk-lsc-interrupt=true</dd>
<dt>Command to set polling mode for a specific interface::</dt>
<dd>$ ovs-vsctl set interface &lt;iface_name&gt; options:dpdk-lsc-interrupt=false</dd>
</dl>
</div>
</div>
<div class="section" id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Currently DPDK ports does not use HW offload functionality.</p>
</li>
<li><p class="first">Network Interface Firmware requirements: Each release of DPDK is
validated against a specific firmware version for a supported Network
Interface. New firmware versions introduce bug fixes, performance
improvements and new functionality that DPDK leverages. The validated
firmware versions are available as part of the release notes for
DPDK. It is recommended that users update Network Interface firmware
to match what has been validated for the DPDK release.</p>
<p>The latest list of validated firmware versions can be found in the <a class="reference external" href="http://dpdk.org/doc/guides/rel_notes/release_17_11.html">DPDK
release notes</a>.</p>
</li>
</ul>
<ul class="simple">
<li>Upper bound MTU: DPDK device drivers differ in how the L2 frame for a
given MTU value is calculated e.g. i40e driver includes 2 x vlan headers in
MTU overhead, em driver includes 1 x vlan header, ixgbe driver does not
include a vlan  header in overhead. Currently it is not possible for OVS
DPDK to know what upper bound MTU value is supported for a given device.
As such OVS DPDK must provision for the case where the L2 frame for a given
MTU includes 2 x vlan headers. This reduces the upper bound MTU value for
devices that do not include vlan headers in their L2 frames by 8 bytes e.g.
ixgbe devices upper bound MTU is reduced from 9710 to 9702. This work
around is temporary and is expected to be removed once a method is provided
by DPDK to query the upper bound MTU value for a given device.</li>
</ul>
</div>
<div class="section" id="reporting-bugs">
<h2>Reporting Bugs<a class="headerlink" href="#reporting-bugs" title="Permalink to this headline">¶</a></h2>
<p>Report problems to <a class="reference external" href="mailto:bugs&#37;&#52;&#48;openvswitch&#46;org">bugs<span>&#64;</span>openvswitch<span>&#46;</span>org</a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../contents.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Open vSwitch with DPDK</a><ul>
<li><a class="reference internal" href="#build-requirements">Build requirements</a></li>
<li><a class="reference internal" href="#installing">Installing</a><ul>
<li><a class="reference internal" href="#install-dpdk">Install DPDK</a></li>
<li><a class="reference internal" href="#install-ovs">Install OVS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#setup">Setup</a><ul>
<li><a class="reference internal" href="#setup-hugepages">Setup Hugepages</a></li>
<li><a class="reference internal" href="#setup-dpdk-devices-using-vfio">Setup DPDK devices using VFIO</a></li>
<li><a class="reference internal" href="#setup-ovs">Setup OVS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#validating">Validating</a></li>
<li><a class="reference internal" href="#performance-tuning">Performance Tuning</a><ul>
<li><a class="reference internal" href="#recommended-bios-settings">Recommended BIOS Settings</a></li>
<li><a class="reference internal" href="#pcie-slot-selection">PCIe Slot Selection</a></li>
<li><a class="reference internal" href="#advanced-hugepage-setup">Advanced Hugepage Setup</a></li>
<li><a class="reference internal" href="#isolate-cores">Isolate Cores</a></li>
<li><a class="reference internal" href="#compiler-optimizations">Compiler Optimizations</a></li>
<li><a class="reference internal" href="#multiple-poll-mode-driver-threads">Multiple Poll-Mode Driver Threads</a></li>
<li><a class="reference internal" href="#affinity">Affinity</a></li>
<li><a class="reference internal" href="#enable-hyperthreading">Enable HyperThreading</a></li>
<li><a class="reference internal" href="#numa-cluster-on-die">NUMA/Cluster-on-Die</a></li>
<li><a class="reference internal" href="#dpdk-physical-port-rx-queues">DPDK Physical Port Rx Queues</a></li>
<li><a class="reference internal" href="#dpdk-physical-port-queue-sizes">DPDK Physical Port Queue Sizes</a></li>
<li><a class="reference internal" href="#exact-match-cache">Exact Match Cache</a></li>
<li><a class="reference internal" href="#rx-mergeable-buffers">Rx Mergeable Buffers</a></li>
<li><a class="reference internal" href="#output-packet-batching">Output Packet Batching</a></li>
<li><a class="reference internal" href="#link-state-change-lsc-detection-configuration">Link State Change (LSC) detection configuration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#reporting-bugs">Reporting Bugs</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Getting Started</a><ul>
  <li><a href="index.html">Installing Open vSwitch</a><ul>
      <li>Previous: <a href="userspace.html" title="previous chapter">Open vSwitch without Kernel Support</a></li>
      <li>Next: <a href="distributions.html" title="next chapter">Distributions packaging Open vSwitch</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/intro/install/dpdk.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, The Open vSwitch Development Community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../../_sources/intro/install/dpdk.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>