
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Using Open vSwitch with DPDK &#8212; Open vSwitch 2.9.2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Open Virtual Networking With Docker" href="docker.html" />
    <link rel="prev" title="Monitoring VM Trafic Using sFlow" href="sflow.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="using-open-vswitch-with-dpdk">
<h1>Using Open vSwitch with DPDK<a class="headerlink" href="#using-open-vswitch-with-dpdk" title="Permalink to this headline">¶</a></h1>
<p>This document describes how to use Open vSwitch with DPDK datapath.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Using the DPDK datapath requires building OVS with DPDK support. Refer to
<a class="reference internal" href="../intro/install/dpdk.html"><span class="doc">Open vSwitch with DPDK</span></a> for more information.</p>
</div>
<div class="section" id="ports-and-bridges">
<h2>Ports and Bridges<a class="headerlink" href="#ports-and-bridges" title="Permalink to this headline">¶</a></h2>
<p>ovs-vsctl can be used to set up bridges and other Open vSwitch features.
Bridges should be created with a <code class="docutils literal notranslate"><span class="pre">datapath_type=netdev</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev
</pre></div>
</div>
<p>ovs-vsctl can also be used to add DPDK devices. ovs-vswitchd should print the
number of dpdk devices found in the log file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdk-p0 -- set Interface dpdk-p0 type=dpdk \
    options:dpdk-devargs=0000:01:00.0
$ ovs-vsctl add-port br0 dpdk-p1 -- set Interface dpdk-p1 type=dpdk \
    options:dpdk-devargs=0000:01:00.1
</pre></div>
</div>
<p>Some NICs (i.e. Mellanox ConnectX-3) have only one PCI address associated
with multiple ports. Using a PCI device like above won’t work. Instead, below
usage is suggested:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdk-p0 -- set Interface dpdk-p0 type=dpdk \
    options:dpdk-devargs=&quot;class=eth,mac=00:11:22:33:44:55&quot;
$ ovs-vsctl add-port br0 dpdk-p1 -- set Interface dpdk-p1 type=dpdk \
    options:dpdk-devargs=&quot;class=eth,mac=00:11:22:33:44:56&quot;
</pre></div>
</div>
<p>Note: such syntax won’t support hotplug. The hotplug is supposed to work with
future DPDK release, v18.05.</p>
<p>After the DPDK ports get added to switch, a polling thread continuously polls
DPDK devices and consumes 100% of the core, as can be checked from <code class="docutils literal notranslate"><span class="pre">top</span></code> and
<code class="docutils literal notranslate"><span class="pre">ps</span></code> commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ top -H
$ ps -eLo pid,psr,comm | grep pmd
</pre></div>
</div>
<p>Creating bonds of DPDK interfaces is slightly different to creating bonds of
system interfaces. For DPDK, the interface type and devargs must be explicitly
set. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-bond br0 dpdkbond p0 p1 \
    -- set Interface p0 type=dpdk options:dpdk-devargs=0000:01:00.0 \
    -- set Interface p1 type=dpdk options:dpdk-devargs=0000:01:00.1
</pre></div>
</div>
<p>To stop ovs-vswitchd &amp; delete bridge, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl -t ovs-vswitchd exit
$ ovs-appctl -t ovsdb-server exit
$ ovs-vsctl del-br br0
</pre></div>
</div>
</div>
<div class="section" id="pmd-thread-statistics">
<h2>PMD Thread Statistics<a class="headerlink" href="#pmd-thread-statistics" title="Permalink to this headline">¶</a></h2>
<p>To show current stats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-stats-show
</pre></div>
</div>
<p>To clear previous stats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-stats-clear
</pre></div>
</div>
</div>
<div class="section" id="port-rxq-assigment-to-pmd-threads">
<h2>Port/RXQ Assigment to PMD Threads<a class="headerlink" href="#port-rxq-assigment-to-pmd-threads" title="Permalink to this headline">¶</a></h2>
<p>To show port/rxq assignment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-rxq-show
</pre></div>
</div>
<p>To change default rxq assignment to pmd threads, rxqs may be manually pinned to
desired cores using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Interface &lt;iface&gt; \
    other_config:pmd-rxq-affinity=&lt;rxq-affinity-list&gt;
</pre></div>
</div>
<p>where:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&lt;rxq-affinity-list&gt;</span></code> is a CSV list of <code class="docutils literal notranslate"><span class="pre">&lt;queue-id&gt;:&lt;core-id&gt;</span></code> values</li>
</ul>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set interface dpdk-p0 options:n_rxq=4 \
    other_config:pmd-rxq-affinity=&quot;0:3,1:7,3:8&quot;
</pre></div>
</div>
<p>This will ensure:</p>
<ul class="simple">
<li>Queue #0 pinned to core 3</li>
<li>Queue #1 pinned to core 7</li>
<li>Queue #2 not pinned</li>
<li>Queue #3 pinned to core 8</li>
</ul>
<p>After that PMD threads on cores where RX queues was pinned will become
<code class="docutils literal notranslate"><span class="pre">isolated</span></code>. This means that this thread will poll only pinned RX queues.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If there are no <code class="docutils literal notranslate"><span class="pre">non-isolated</span></code> PMD threads, <code class="docutils literal notranslate"><span class="pre">non-pinned</span></code> RX queues will
not be polled. Also, if provided <code class="docutils literal notranslate"><span class="pre">core_id</span></code> is not available (ex. this
<code class="docutils literal notranslate"><span class="pre">core_id</span></code> not in <code class="docutils literal notranslate"><span class="pre">pmd-cpu-mask</span></code>), RX queue will not be polled by any PMD
thread.</p>
</div>
<p>If pmd-rxq-affinity is not set for rxqs, they will be assigned to pmds (cores)
automatically. The processing cycles that have been stored for each rxq
will be used where known to assign rxqs to pmd based on a round robin of the
sorted rxqs.</p>
<p>For example, in the case where here there are 5 rxqs and 3 cores (e.g. 3,7,8)
available, and the measured usage of core cycles per rxq over the last
interval is seen to be:</p>
<ul class="simple">
<li>Queue #0: 30%</li>
<li>Queue #1: 80%</li>
<li>Queue #3: 60%</li>
<li>Queue #4: 70%</li>
<li>Queue #5: 10%</li>
</ul>
<p>The rxqs will be assigned to cores 3,7,8 in the following order:</p>
<p>Core 3: Q1 (80%) |
Core 7: Q4 (70%) | Q5 (10%)
core 8: Q3 (60%) | Q0 (30%)</p>
<p>To see the current measured usage history of pmd core cycles for each rxq:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-rxq-show
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A history of one minute is recorded and shown for each rxq to allow for
traffic pattern spikes. An rxq’s pmd core cycles usage changes due to traffic
pattern or reconfig changes will take one minute before they are fully
reflected in the stats.</p>
</div>
<p>Rxq to pmds assignment takes place whenever there are configuration changes
or can be triggered by using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-rxq-rebalance
</pre></div>
</div>
</div>
<div class="section" id="qos">
<h2>QoS<a class="headerlink" href="#qos" title="Permalink to this headline">¶</a></h2>
<p>Assuming you have a vhost-user port transmitting traffic consisting of packets
of size 64 bytes, the following command would limit the egress transmission
rate of the port to ~1,000,000 packets per second:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set port vhost-user0 qos=@newqos -- \
    --id=@newqos create qos type=egress-policer other-config:cir=46000000 \
    other-config:cbs=2048`
</pre></div>
</div>
<p>To examine the QoS configuration of the port, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl -t ovs-vswitchd qos/show vhost-user0
</pre></div>
</div>
<p>To clear the QoS configuration from the port and ovsdb, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl destroy QoS vhost-user0 -- clear Port vhost-user0 qos
</pre></div>
</div>
<p>Refer to vswitch.xml for more details on egress-policer.</p>
</div>
<div class="section" id="rate-limiting">
<h2>Rate Limiting<a class="headerlink" href="#rate-limiting" title="Permalink to this headline">¶</a></h2>
<p>Here is an example on Ingress Policing usage. Assuming you have a vhost-user
port receiving traffic consisting of packets of size 64 bytes, the following
command would limit the reception rate of the port to ~1,000,000 packets per
second:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set interface vhost-user0 ingress_policing_rate=368000 \
    ingress_policing_burst=1000`
</pre></div>
</div>
<p>To examine the ingress policer configuration of the port:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl list interface vhost-user0
</pre></div>
</div>
<p>To clear the ingress policer configuration from the port:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set interface vhost-user0 ingress_policing_rate=0
</pre></div>
</div>
<p>Refer to vswitch.xml for more details on ingress-policer.</p>
</div>
<div class="section" id="flow-control">
<h2>Flow Control<a class="headerlink" href="#flow-control" title="Permalink to this headline">¶</a></h2>
<p>Flow control can be enabled only on DPDK physical ports. To enable flow control
support at tx side while adding a port, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdk-p0 -- set Interface dpdk-p0 type=dpdk \
    options:dpdk-devargs=0000:01:00.0 options:tx-flow-ctrl=true
</pre></div>
</div>
<p>Similarly, to enable rx flow control, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdk-p0 -- set Interface dpdk-p0 type=dpdk \
    options:dpdk-devargs=0000:01:00.0 options:rx-flow-ctrl=true
</pre></div>
</div>
<p>To enable flow control auto-negotiation, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdk-p0 -- set Interface dpdk-p0 type=dpdk \
    options:dpdk-devargs=0000:01:00.0 options:flow-ctrl-autoneg=true
</pre></div>
</div>
<p>To turn ON the tx flow control at run time for an existing port, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Interface dpdk-p0 options:tx-flow-ctrl=true
</pre></div>
</div>
<p>The flow control parameters can be turned off by setting <code class="docutils literal notranslate"><span class="pre">false</span></code> to the
respective parameter. To disable the flow control at tx side, run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Interface dpdk-p0 options:tx-flow-ctrl=false
</pre></div>
</div>
</div>
<div class="section" id="pdump">
<h2>pdump<a class="headerlink" href="#pdump" title="Permalink to this headline">¶</a></h2>
<p>pdump allows you to listen on DPDK ports and view the traffic that is passing
on them. To use this utility, one must have libpcap installed on the system.
Furthermore, DPDK must be built with <code class="docutils literal notranslate"><span class="pre">CONFIG_RTE_LIBRTE_PDUMP=y</span></code> and
<code class="docutils literal notranslate"><span class="pre">CONFIG_RTE_LIBRTE_PMD_PCAP=y</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A performance decrease is expected when using a monitoring application like
the DPDK pdump app.</p>
</div>
<p>To use pdump, simply launch OVS as usual, then navigate to the <code class="docutils literal notranslate"><span class="pre">app/pdump</span></code>
directory in DPDK, <code class="docutils literal notranslate"><span class="pre">make</span></code> the application and run like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo ./build/app/dpdk-pdump -- \
    --pdump port=0,queue=0,rx-dev=/tmp/pkts.pcap \
    --server-socket-path=/usr/local/var/run/openvswitch
</pre></div>
</div>
<p>The above command captures traffic received on queue 0 of port 0 and stores it
in <code class="docutils literal notranslate"><span class="pre">/tmp/pkts.pcap</span></code>. Other combinations of port numbers, queues numbers and
pcap locations are of course also available to use. For example, to capture all
packets that traverse port 0 in a single pcap file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sudo ./build/app/dpdk-pdump -- \
    --pdump &#39;port=0,queue=*,rx-dev=/tmp/pkts.pcap,tx-dev=/tmp/pkts.pcap&#39; \
    --server-socket-path=/usr/local/var/run/openvswitch
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">server-socket-path</span></code> must be set to the value of <code class="docutils literal notranslate"><span class="pre">ovs_rundir()</span></code> which
typically resolves to <code class="docutils literal notranslate"><span class="pre">/usr/local/var/run/openvswitch</span></code>.</p>
<p>Many tools are available to view the contents of the pcap file. Once example is
tcpdump. Issue the following command to view the contents of <code class="docutils literal notranslate"><span class="pre">pkts.pcap</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ tcpdump -r pkts.pcap
</pre></div>
</div>
<p>More information on the pdump app and its usage can be found in the <a class="reference external" href="http://dpdk.org/doc/guides/tools/pdump.html">DPDK docs</a>.</p>
</div>
<div class="section" id="jumbo-frames">
<h2>Jumbo Frames<a class="headerlink" href="#jumbo-frames" title="Permalink to this headline">¶</a></h2>
<p>By default, DPDK ports are configured with standard Ethernet MTU (1500B). To
enable Jumbo Frames support for a DPDK port, change the Interface’s
<code class="docutils literal notranslate"><span class="pre">mtu_request</span></code> attribute to a sufficiently large value. For example, to add a
DPDK Phy port with MTU of 9000:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdk-p0 -- set Interface dpdk-p0 type=dpdk \
      options:dpdk-devargs=0000:01:00.0 mtu_request=9000
</pre></div>
</div>
<p>Similarly, to change the MTU of an existing port to 6200:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Interface dpdk-p0 mtu_request=6200
</pre></div>
</div>
<p>Some additional configuration is needed to take advantage of jumbo frames with
vHost ports:</p>
<ol class="arabic">
<li><p class="first"><em>mergeable buffers</em> must be enabled for vHost ports, as demonstrated in the
QEMU command line snippet below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">netdev</span> <span class="nb">type</span><span class="o">=</span><span class="n">vhost</span><span class="o">-</span><span class="n">user</span><span class="p">,</span><span class="nb">id</span><span class="o">=</span><span class="n">mynet1</span><span class="p">,</span><span class="n">chardev</span><span class="o">=</span><span class="n">char0</span><span class="p">,</span><span class="n">vhostforce</span> \
<span class="o">-</span><span class="n">device</span> <span class="n">virtio</span><span class="o">-</span><span class="n">net</span><span class="o">-</span><span class="n">pci</span><span class="p">,</span><span class="n">mac</span><span class="o">=</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">01</span><span class="p">,</span><span class="n">netdev</span><span class="o">=</span><span class="n">mynet1</span><span class="p">,</span><span class="n">mrg_rxbuf</span><span class="o">=</span><span class="n">on</span>
</pre></div>
</div>
</li>
<li><p class="first">Where virtio devices are bound to the Linux kernel driver in a guest
environment (i.e. interfaces are not bound to an in-guest DPDK driver), the
MTU of those logical network interfaces must also be increased to a
sufficiently large value. This avoids segmentation of Jumbo Frames received
in the guest. Note that ‘MTU’ refers to the length of the IP packet only,
and not that of the entire frame.</p>
<p>To calculate the exact MTU of a standard IPv4 frame, subtract the L2 header
and CRC lengths (i.e. 18B) from the max supported frame size.  So, to set
the MTU for a 9018B Jumbo Frame:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ip link set eth1 mtu 9000
</pre></div>
</div>
</li>
</ol>
<p>When Jumbo Frames are enabled, the size of a DPDK port’s mbuf segments are
increased, such that a full Jumbo Frame of a specific size may be accommodated
within a single mbuf segment.</p>
<p>Jumbo frame support has been validated against 9728B frames, which is the
largest frame size supported by Fortville NIC using the DPDK i40e driver, but
larger frames and other DPDK NIC drivers may be supported. These cases are
common for use cases involving East-West traffic only.</p>
</div>
<div class="section" id="rx-checksum-offload">
<h2>Rx Checksum Offload<a class="headerlink" href="#rx-checksum-offload" title="Permalink to this headline">¶</a></h2>
<p>By default, DPDK physical ports are enabled with Rx checksum offload.</p>
<p>Rx checksum offload can offer performance improvement only for tunneling
traffic in OVS-DPDK because the checksum validation of tunnel packets is
offloaded to the NIC. Also enabling Rx checksum may slightly reduce the
performance of non-tunnel traffic, specifically for smaller size packet.</p>
</div>
<div class="section" id="extended-custom-statistics">
<span id="extended-statistics"></span><h2>Extended &amp; Custom Statistics<a class="headerlink" href="#extended-custom-statistics" title="Permalink to this headline">¶</a></h2>
<p>DPDK Extended Statistics API allows PMD to expose unique set of statistics.
The Extended statistics are implemented and supported only for DPDK physical
and vHost ports. Custom statistics are dynamic set of counters which can
vary depenend on a driver. Those statistics are implemented
for DPDK physical ports and contain all “dropped”, “error” and “management”
counters from XSTATS. XSTATS counters list can be found here:
&lt;<a class="reference external" href="https://wiki.opnfv.org/display/fastpath/Collectd+Metrics+and+Events">https://wiki.opnfv.org/display/fastpath/Collectd+Metrics+and+Events</a>&gt;`__.</p>
<p>To enable statistics, you have to enable OpenFlow 1.4 support for OVS.
Configure bridge br0 to support OpenFlow version 1.4:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set bridge br0 datapath_type=netdev \
  protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13,OpenFlow14
</pre></div>
</div>
<p>Check the OVSDB protocols column in the bridge table if OpenFlow 1.4 support
is enabled for OVS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovsdb-client dump Bridge protocols
</pre></div>
</div>
<p>Query the port statistics by explicitly specifying -O OpenFlow14 option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-ofctl -O OpenFlow14 dump-ports br0
</pre></div>
</div>
<p>Note about “Extended Statistics”: vHost ports supports only partial
statistics. RX packet size based counter are only supported and
doesn’t include TX packet size counters.</p>
</div>
<div class="section" id="port-hotplug">
<span id="id1"></span><h2>Port Hotplug<a class="headerlink" href="#port-hotplug" title="Permalink to this headline">¶</a></h2>
<p>OVS supports port hotplugging, allowing the use of ports that were not bound
to DPDK when vswitchd was started.
In order to attach a port, it has to be bound to DPDK using the
<code class="docutils literal notranslate"><span class="pre">dpdk_nic_bind.py</span></code> script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ $DPDK_DIR/tools/dpdk_nic_bind.py --bind=igb_uio 0000:01:00.0
</pre></div>
</div>
<p>Then it can be attached to OVS:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 dpdkx -- set Interface dpdkx type=dpdk \
    options:dpdk-devargs=0000:01:00.0
</pre></div>
</div>
<p>Detaching will be performed while processing del-port command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl del-port dpdkx
</pre></div>
</div>
<p>Sometimes, the del-port command may not detach the device.
Detaching can be confirmed by the appearance of an INFO log.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INFO</span><span class="o">|</span><span class="n">Device</span> <span class="s1">&#39;0000:04:00.1&#39;</span> <span class="n">has</span> <span class="n">been</span> <span class="n">detached</span>
</pre></div>
</div>
<p>If the log is not seen, then the port can be detached using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl netdev-dpdk/detach 0000:01:00.0
</pre></div>
</div>
<p>Detaching can be confirmed by console output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Device</span> <span class="s1">&#39;0000:04:00.1&#39;</span> <span class="n">has</span> <span class="n">been</span> <span class="n">detached</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Detaching should not be done if a device is known to be non-detachable, as
this may cause the device to behave improperly when added back with
add-port. The Chelsio Terminator adapters which use the cxgbe driver seem
to be an example of this behavior; check the driver documentation if this
is suspected.</p>
</div>
<p>This feature does not work with some NICs.
For more information please refer to the <a class="reference external" href="http://dpdk.org/doc/guides/prog_guide/port_hotplug_framework.html#hotplug">DPDK Port Hotplug Framework</a>.</p>
</div>
<div class="section" id="vdev-support">
<span id="id2"></span><h2>Vdev Support<a class="headerlink" href="#vdev-support" title="Permalink to this headline">¶</a></h2>
<p>DPDK provides drivers for both physical and virtual devices. Physical DPDK
devices are added to OVS by specifying a valid PCI address in ‘dpdk-devargs’.
Virtual DPDK devices which do not have PCI addresses can be added using a
different format for ‘dpdk-devargs’.</p>
<p>Typically, the format expected is ‘eth_&lt;driver_name&gt;&lt;x&gt;’ where ‘x’ is a
unique identifier of your choice for the given port.</p>
<p>For example to add a dpdk port that uses the ‘null’ DPDK PMD driver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 null0 -- set Interface null0 type=dpdk \
    options:dpdk-devargs=eth_null0
</pre></div>
</div>
<p>Similarly, to add a dpdk port that uses the ‘af_packet’ DPDK PMD driver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl add-port br0 myeth0 -- set Interface myeth0 type=dpdk \
    options:dpdk-devargs=eth_af_packet0,iface=eth0
</pre></div>
</div>
<p>More information on the different types of virtual DPDK PMDs can be found in
the <a class="reference external" href="http://dpdk.org/doc/guides/nics/overview.html">DPDK documentation</a>.</p>
<p>Note: Not all DPDK virtual PMD drivers have been tested and verified to work.</p>
</div>
<div class="section" id="emc-insertion-probability">
<h2>EMC Insertion Probability<a class="headerlink" href="#emc-insertion-probability" title="Permalink to this headline">¶</a></h2>
<p>By default 1 in every 100 flows are inserted into the Exact Match Cache (EMC).
It is possible to change this insertion probability by setting the
<code class="docutils literal notranslate"><span class="pre">emc-insert-inv-prob</span></code> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl --no-wait set Open_vSwitch . other_config:emc-insert-inv-prob=N
</pre></div>
</div>
<p>where:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt>
<dd>is a positive integer representing the inverse probability of insertion ie.
on average 1 in every N packets with a unique flow will generate an EMC
insertion.</dd>
</dl>
<p>If <code class="docutils literal notranslate"><span class="pre">N</span></code> is set to 1, an insertion will be performed for every flow. If set to
0, no insertions will be performed and the EMC will effectively be disabled.</p>
<p>With default <code class="docutils literal notranslate"><span class="pre">N</span></code> set to 100, higher megaflow hits will occur initially
as observed with pmd stats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-appctl dpif-netdev/pmd-stats-show
</pre></div>
</div>
<p>For certain traffic profiles with many parallel flows, it’s recommended to set
<code class="docutils literal notranslate"><span class="pre">N</span></code> to ‘0’ to achieve higher forwarding performance.</p>
<p>For more information on the EMC refer to <a class="reference internal" href="../intro/install/dpdk.html"><span class="doc">Open vSwitch with DPDK</span></a> .</p>
</div>
<div class="section" id="ovs-with-dpdk-inside-vms">
<span id="dpdk-ovs-in-guest"></span><h2>OVS with DPDK Inside VMs<a class="headerlink" href="#ovs-with-dpdk-inside-vms" title="Permalink to this headline">¶</a></h2>
<p>Additional configuration is required if you want to run ovs-vswitchd with DPDK
backend inside a QEMU virtual machine. ovs-vswitchd creates separate DPDK TX
queues for each CPU core available. This operation fails inside QEMU virtual
machine because, by default, VirtIO NIC provided to the guest is configured to
support only single TX queue and single RX queue. To change this behavior, you
need to turn on <code class="docutils literal notranslate"><span class="pre">mq</span></code> (multiqueue) property of all <code class="docutils literal notranslate"><span class="pre">virtio-net-pci</span></code> devices
emulated by QEMU and used by DPDK.  You may do it manually (by changing QEMU
command line) or, if you use Libvirt, by adding the following string to
<code class="docutils literal notranslate"><span class="pre">&lt;interface&gt;</span></code> sections of all network devices used by DPDK:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">driver</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;vhost&#39;</span> <span class="n">queues</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="o">/&gt;</span>
</pre></div>
</div>
<p>where:</p>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">N</span></code></dt>
<dd>determines how many queues can be used by the guest.</dd>
</dl>
<p>This requires QEMU &gt;= 2.2.</p>
</div>
<div class="section" id="phy-phy">
<span id="dpdk-phy-phy"></span><h2>PHY-PHY<a class="headerlink" href="#phy-phy" title="Permalink to this headline">¶</a></h2>
<p>Add a userspace bridge and two <code class="docutils literal notranslate"><span class="pre">dpdk</span></code> (PHY) ports:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Add userspace bridge
$ ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev

# Add two dpdk ports
$ ovs-vsctl add-port br0 phy0 -- set Interface phy0 type=dpdk \
      options:dpdk-devargs=0000:01:00.0 ofport_request=1

$ ovs-vsctl add-port br0 phy1 -- set Interface phy1 type=dpdk
      options:dpdk-devargs=0000:01:00.1 ofport_request=2
</pre></div>
</div>
<p>Add test flows to forward packets betwen DPDK port 0 and port 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Clear current flows
$ ovs-ofctl del-flows br0

# Add flows between port 1 (phy0) to port 2 (phy1)
$ ovs-ofctl add-flow br0 in_port=1,action=output:2
$ ovs-ofctl add-flow br0 in_port=2,action=output:1
</pre></div>
</div>
<p>Transmit traffic into either port. You should see it returned via the other.</p>
</div>
<div class="section" id="phy-vm-phy-vhost-loopback">
<span id="dpdk-vhost-loopback"></span><h2>PHY-VM-PHY (vHost Loopback)<a class="headerlink" href="#phy-vm-phy-vhost-loopback" title="Permalink to this headline">¶</a></h2>
<p>Add a userspace bridge, two <code class="docutils literal notranslate"><span class="pre">dpdk</span></code> (PHY) ports, and two <code class="docutils literal notranslate"><span class="pre">dpdkvhostuser</span></code>
ports:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Add userspace bridge
$ ovs-vsctl add-br br0 -- set bridge br0 datapath_type=netdev

# Add two dpdk ports
$ ovs-vsctl add-port br0 phy0 -- set Interface phy0 type=dpdk \
      options:dpdk-devargs=0000:01:00.0 ofport_request=1

$ ovs-vsctl add-port br0 phy1 -- set Interface phy1 type=dpdk
      options:dpdk-devargs=0000:01:00.1 ofport_request=2

# Add two dpdkvhostuser ports
$ ovs-vsctl add-port br0 dpdkvhostuser0 \
    -- set Interface dpdkvhostuser0 type=dpdkvhostuser ofport_request=3
$ ovs-vsctl add-port br0 dpdkvhostuser1 \
    -- set Interface dpdkvhostuser1 type=dpdkvhostuser ofport_request=4
</pre></div>
</div>
<p>Add test flows to forward packets betwen DPDK devices and VM ports:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Clear current flows
$ ovs-ofctl del-flows br0

# Add flows
$ ovs-ofctl add-flow br0 in_port=1,action=output:3
$ ovs-ofctl add-flow br0 in_port=3,action=output:1
$ ovs-ofctl add-flow br0 in_port=4,action=output:2
$ ovs-ofctl add-flow br0 in_port=2,action=output:4

# Dump flows
$ ovs-ofctl dump-flows br0
</pre></div>
</div>
<p>Create a VM using the following configuration:</p>
<table border="1" class="docutils">
<colgroup>
<col width="51%" />
<col width="20%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Configuration</th>
<th class="head">Values</th>
<th class="head">Comments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QEMU version</td>
<td>2.2.0</td>
<td>n/a</td>
</tr>
<tr class="row-odd"><td>QEMU thread affinity</td>
<td>core 5</td>
<td>taskset 0x20</td>
</tr>
<tr class="row-even"><td>Memory</td>
<td>4GB</td>
<td>n/a</td>
</tr>
<tr class="row-odd"><td>Cores</td>
<td>2</td>
<td>n/a</td>
</tr>
<tr class="row-even"><td>Qcow2 image</td>
<td>CentOS7</td>
<td>n/a</td>
</tr>
<tr class="row-odd"><td>mrg_rxbuf</td>
<td>off</td>
<td>n/a</td>
</tr>
</tbody>
</table>
<p>You can do this directly with QEMU via the <code class="docutils literal notranslate"><span class="pre">qemu-system-x86_64</span></code> application:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export VM_NAME=vhost-vm
$ export GUEST_MEM=3072M
$ export QCOW2_IMAGE=/root/CentOS7_x86_64.qcow2
$ export VHOST_SOCK_DIR=/usr/local/var/run/openvswitch

$ taskset 0x20 qemu-system-x86_64 -name $VM_NAME -cpu host -enable-kvm \
  -m $GUEST_MEM -drive file=$QCOW2_IMAGE --nographic -snapshot \
  -numa node,memdev=mem -mem-prealloc -smp sockets=1,cores=2 \
  -object memory-backend-file,id=mem,size=$GUEST_MEM,mem-path=/dev/hugepages,share=on \
  -chardev socket,id=char0,path=$VHOST_SOCK_DIR/dpdkvhostuser0 \
  -netdev type=vhost-user,id=mynet1,chardev=char0,vhostforce \
  -device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1,mrg_rxbuf=off \
  -chardev socket,id=char1,path=$VHOST_SOCK_DIR/dpdkvhostuser1 \
  -netdev type=vhost-user,id=mynet2,chardev=char1,vhostforce \
  -device virtio-net-pci,mac=00:00:00:00:00:02,netdev=mynet2,mrg_rxbuf=off
</pre></div>
</div>
<p>For a explanation of this command, along with alternative approaches such as
booting the VM via libvirt, refer to <a class="reference internal" href="../topics/dpdk/vhost-user.html"><span class="doc">DPDK vHost User Ports</span></a>.</p>
<p>Once the guest is configured and booted, configure DPDK packet forwarding
within the guest. To accomplish this, build the <code class="docutils literal notranslate"><span class="pre">testpmd</span></code> application as
described in <a class="reference internal" href="../topics/dpdk/vhost-user.html#dpdk-testpmd"><span class="std std-ref">DPDK in the Guest</span></a>. Once compiled, run the application:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cd $DPDK_DIR/app/test-pmd;
$ ./testpmd -c 0x3 -n 4 --socket-mem 1024 -- \
    --burst=64 -i --txqflags=0xf00 --disable-hw-vlan
$ set fwd mac retry
$ start
</pre></div>
</div>
<p>When you finish testing, bind the vNICs back to kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ $DPDK_DIR/usertools/dpdk-devbind.py --bind=virtio-pci 0000:00:03.0
$ $DPDK_DIR/usertools/dpdk-devbind.py --bind=virtio-pci 0000:00:04.0
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Valid PCI IDs must be passed in above example. The PCI IDs can be retrieved
like so:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>$ $DPDK_DIR/usertools/dpdk-devbind.py --status
</pre></div>
</div>
</div>
<p>More information on the dpdkvhostuser ports can be found in
<a class="reference internal" href="../topics/dpdk/vhost-user.html"><span class="doc">DPDK vHost User Ports</span></a>.</p>
<div class="section" id="phy-vm-phy-vhost-loopback-kernel-forwarding">
<h3>PHY-VM-PHY (vHost Loopback) (Kernel Forwarding)<a class="headerlink" href="#phy-vm-phy-vhost-loopback-kernel-forwarding" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#dpdk-vhost-loopback"><span class="std std-ref">PHY-VM-PHY (vHost Loopback)</span></a> details steps for PHY-VM-PHY loopback
testcase and packet forwarding using DPDK testpmd application in the Guest VM.
For users wishing to do packet forwarding using kernel stack below, you need to
run the below commands on the guest:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ip addr add 1.1.1.2/24 dev eth1
$ ip addr add 1.1.2.2/24 dev eth2
$ ip link set eth1 up
$ ip link set eth2 up
$ systemctl stop firewalld.service
$ systemctl stop iptables.service
$ sysctl -w net.ipv4.ip_forward=1
$ sysctl -w net.ipv4.conf.all.rp_filter=0
$ sysctl -w net.ipv4.conf.eth1.rp_filter=0
$ sysctl -w net.ipv4.conf.eth2.rp_filter=0
$ route add -net 1.1.2.0/24 eth2
$ route add -net 1.1.1.0/24 eth1
$ arp -s 1.1.2.99 DE:AD:BE:EF:CA:FE
$ arp -s 1.1.1.99 DE:AD:BE:EF:CA:EE
</pre></div>
</div>
</div>
<div class="section" id="phy-vm-phy-vhost-multiqueue">
<h3>PHY-VM-PHY (vHost Multiqueue)<a class="headerlink" href="#phy-vm-phy-vhost-multiqueue" title="Permalink to this headline">¶</a></h3>
<p>vHost Multiqueue functionality can also be validated using the PHY-VM-PHY
configuration. To begin, follow the steps described in <a class="reference internal" href="#dpdk-phy-phy"><span class="std std-ref">PHY-PHY</span></a> to
create and initialize the database, start ovs-vswitchd and add <code class="docutils literal notranslate"><span class="pre">dpdk</span></code>-type
devices to bridge <code class="docutils literal notranslate"><span class="pre">br0</span></code>. Once complete, follow the below steps:</p>
<ol class="arabic">
<li><p class="first">Configure PMD and RXQs.</p>
<p>For example, set the number of dpdk port rx queues to at least 2  The number
of rx queues at vhost-user interface gets automatically configured after
virtio device connection and doesn’t need manual configuration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ovs-vsctl set Open_vSwitch . other_config:pmd-cpu-mask=0xc
$ ovs-vsctl set Interface phy0 options:n_rxq=2
$ ovs-vsctl set Interface phy1 options:n_rxq=2
</pre></div>
</div>
</li>
<li><p class="first">Instantiate Guest VM using QEMU cmdline</p>
<p>We must configure with appropriate software versions to ensure this feature
is supported.</p>
<table border="1" class="docutils" id="id3">
<caption><span class="caption-text">Recommended BIOS Settings</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Setting</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QEMU version</td>
<td>2.5.0</td>
</tr>
<tr class="row-odd"><td>QEMU thread affinity</td>
<td>2 cores (taskset 0x30)</td>
</tr>
<tr class="row-even"><td>Memory</td>
<td>4 GB</td>
</tr>
<tr class="row-odd"><td>Cores</td>
<td>2</td>
</tr>
<tr class="row-even"><td>Distro</td>
<td>Fedora 22</td>
</tr>
<tr class="row-odd"><td>Multiqueue</td>
<td>Enabled</td>
</tr>
</tbody>
</table>
<p>To do this, instantiate the guest as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export VM_NAME=vhost-vm
$ export GUEST_MEM=4096M
$ export QCOW2_IMAGE=/root/Fedora22_x86_64.qcow2
$ export VHOST_SOCK_DIR=/usr/local/var/run/openvswitch
$ taskset 0x30 qemu-system-x86_64 -cpu host -smp 2,cores=2 -m 4096M \
    -drive file=$QCOW2_IMAGE --enable-kvm -name $VM_NAME \
    -nographic -numa node,memdev=mem -mem-prealloc \
    -object memory-backend-file,id=mem,size=$GUEST_MEM,mem-path=/dev/hugepages,share=on \
    -chardev socket,id=char1,path=$VHOST_SOCK_DIR/dpdkvhostuser0 \
    -netdev type=vhost-user,id=mynet1,chardev=char1,vhostforce,queues=2 \
    -device virtio-net-pci,mac=00:00:00:00:00:01,netdev=mynet1,mq=on,vectors=6 \
    -chardev socket,id=char2,path=$VHOST_SOCK_DIR/dpdkvhostuser1 \
    -netdev type=vhost-user,id=mynet2,chardev=char2,vhostforce,queues=2 \
    -device virtio-net-pci,mac=00:00:00:00:00:02,netdev=mynet2,mq=on,vectors=6
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Queue value above should match the queues configured in OVS, The vector
value should be set to “number of queues x 2 + 2”</p>
</div>
</li>
<li><p class="first">Configure the guest interface</p>
<p>Assuming there are 2 interfaces in the guest named eth0, eth1 check the
channel configuration and set the number of combined channels to 2 for
virtio devices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ethtool -l eth0
$ ethtool -L eth0 combined 2
$ ethtool -L eth1 combined 2
</pre></div>
</div>
<p>More information can be found in vHost walkthrough section.</p>
</li>
<li><p class="first">Configure kernel packet forwarding</p>
<p>Configure IP and enable interfaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ip addr add 5.5.5.1/24 dev eth0
$ ip addr add 90.90.90.1/24 dev eth1
$ ip link set eth0 up
$ ip link set eth1 up
</pre></div>
</div>
<p>Configure IP forwarding and add route entries:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ sysctl -w net.ipv4.ip_forward=1
$ sysctl -w net.ipv4.conf.all.rp_filter=0
$ sysctl -w net.ipv4.conf.eth0.rp_filter=0
$ sysctl -w net.ipv4.conf.eth1.rp_filter=0
$ ip route add 2.1.1.0/24 dev eth1
$ route add default gw 2.1.1.2 eth1
$ route add default gw 90.90.90.90 eth1
$ arp -s 90.90.90.90 DE:AD:BE:EF:CA:FE
$ arp -s 2.1.1.2 DE:AD:BE:EF:CA:FA
</pre></div>
</div>
<p>Check traffic on multiple queues:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ cat /proc/interrupts | grep virtio
</pre></div>
</div>
</li>
</ol>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using Open vSwitch with DPDK</a><ul>
<li><a class="reference internal" href="#ports-and-bridges">Ports and Bridges</a></li>
<li><a class="reference internal" href="#pmd-thread-statistics">PMD Thread Statistics</a></li>
<li><a class="reference internal" href="#port-rxq-assigment-to-pmd-threads">Port/RXQ Assigment to PMD Threads</a></li>
<li><a class="reference internal" href="#qos">QoS</a></li>
<li><a class="reference internal" href="#rate-limiting">Rate Limiting</a></li>
<li><a class="reference internal" href="#flow-control">Flow Control</a></li>
<li><a class="reference internal" href="#pdump">pdump</a></li>
<li><a class="reference internal" href="#jumbo-frames">Jumbo Frames</a></li>
<li><a class="reference internal" href="#rx-checksum-offload">Rx Checksum Offload</a></li>
<li><a class="reference internal" href="#extended-custom-statistics">Extended &amp; Custom Statistics</a></li>
<li><a class="reference internal" href="#port-hotplug">Port Hotplug</a></li>
<li><a class="reference internal" href="#vdev-support">Vdev Support</a></li>
<li><a class="reference internal" href="#emc-insertion-probability">EMC Insertion Probability</a></li>
<li><a class="reference internal" href="#ovs-with-dpdk-inside-vms">OVS with DPDK Inside VMs</a></li>
<li><a class="reference internal" href="#phy-phy">PHY-PHY</a></li>
<li><a class="reference internal" href="#phy-vm-phy-vhost-loopback">PHY-VM-PHY (vHost Loopback)</a><ul>
<li><a class="reference internal" href="#phy-vm-phy-vhost-loopback-kernel-forwarding">PHY-VM-PHY (vHost Loopback) (Kernel Forwarding)</a></li>
<li><a class="reference internal" href="#phy-vm-phy-vhost-multiqueue">PHY-VM-PHY (vHost Multiqueue)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">How-to Guides</a><ul>
      <li>Previous: <a href="sflow.html" title="previous chapter">Monitoring VM Trafic Using sFlow</a></li>
      <li>Next: <a href="docker.html" title="next chapter">Open Virtual Networking With Docker</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/howto/dpdk.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, The Open vSwitch Development Community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/howto/dpdk.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>