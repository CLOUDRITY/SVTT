
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ovsdb &#8212; Open vSwitch 2.9.2 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Open vSwitch FAQ" href="../faq/index.html" />
    <link rel="prev" title="ovsdb" href="ovsdb.5.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ovsdb">
<h1>ovsdb<a class="headerlink" href="#ovsdb" title="Permalink to this headline">¶</a></h1>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>OVSDB, the Open vSwitch Database, is a network-accessible database system.
Schemas in OVSDB specify the tables in a database and their columns’ types and
can include data, uniqueness, and referential integrity constraints.  OVSDB
offers atomic, consistent, isolated, durable transactions.  RFC 7047 specifies
the JSON-RPC based protocol that OVSDB clients and servers use to communicate.</p>
<p>The OVSDB protocol is well suited for state synchronization because it
allows each client to monitor the contents of a whole database or a subset
of it.  Whenever a monitored portion of the database changes, the server
tells the client what rows were added or modified (including the new
contents) or deleted.  Thus, OVSDB clients can easily keep track of the
newest contents of any part of the database.</p>
<p>While OVSDB is general-purpose and not particularly specialized for use with
Open vSwitch, Open vSwitch does use it for multiple purposes.  The leading use
of OVSDB is for configuring and monitoring <code class="docutils literal notranslate"><span class="pre">ovs-vswitchd(8)</span></code>, the Open
vSwitch switch daemon, using the schema documented in
<code class="docutils literal notranslate"><span class="pre">ovs-vswitchd.conf.db(5)</span></code>.  The Open Virtual Network (OVN) sub-project of OVS
uses two OVSDB schemas, documented in <code class="docutils literal notranslate"><span class="pre">ovn-nb(5)</span></code> and <code class="docutils literal notranslate"><span class="pre">ovn-sb(5)</span></code>.
Finally, Open vSwitch includes the “VTEP” schema, documented in
<code class="docutils literal notranslate"><span class="pre">vtep(5)</span></code> that many third-party hardware switches support for
configuring VXLAN, although OVS itself does not directly use this schema.</p>
<p>The OVSDB protocol specification allows independent, interoperable
implementations of OVSDB to be developed.  Open vSwitch includes an OVSDB
server implementation named <code class="docutils literal notranslate"><span class="pre">ovsdb-server(1)</span></code>, which supports several
protocol extensions documented in its manpage, and a basic command-line OVSDB
client named <code class="docutils literal notranslate"><span class="pre">ovsdb-client(1)</span></code>, as well as OVSDB client libraries for C and
for Python.  Open vSwitch documentation often speaks of these OVSDB
implementations in Open vSwitch as simply “OVSDB,” even though that is distinct
from the OVSDB protocol; we make the distinction explicit only when it might
otherwise be unclear from the context.</p>
<p>In addition to these generic OVSDB server and client tools, Open vSwitch
includes tools for working with databases that have specific schemas:
<code class="docutils literal notranslate"><span class="pre">ovs-vsctl</span></code> works with the <code class="docutils literal notranslate"><span class="pre">ovs-vswitchd</span></code> configuration database,
<code class="docutils literal notranslate"><span class="pre">vtep-ctl</span></code> works with the VTEP database, <code class="docutils literal notranslate"><span class="pre">ovn-nbctl</span></code> works with
the OVN Northbound database, and so on.</p>
<p>RFC 7047 specifies the OVSDB protocol but it does not specify an on-disk
storage format.  Open vSwitch includes <code class="docutils literal notranslate"><span class="pre">ovsdb-tool(1)</span></code> for working with its
own on-disk database formats.  The most notable feature of this format is that
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool(1)</span></code> makes it easy for users to print the transactions that have
changed a database since the last time it was compacted.  This feature is often
useful for troubleshooting.</p>
</div>
<div class="section" id="schemas">
<h2>Schemas<a class="headerlink" href="#schemas" title="Permalink to this headline">¶</a></h2>
<p>Schemas in OVSDB have a JSON format that is specified in RFC 7047.  They
are often stored in files with an extension <code class="docutils literal notranslate"><span class="pre">.ovsschema</span></code>.  An
on-disk database in OVSDB includes a schema and data, embedding both into a
single file.  The Open vSwitch utility <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> has commands
that work with schema files and with the schemas embedded in database
files.</p>
<p>An Open vSwitch schema has three important identifiers.  The first is its
name, which is also the name used in JSON-RPC calls to identify a database
based on that schema.  For example, the schema used to configure Open
vSwitch has the name <code class="docutils literal notranslate"><span class="pre">Open_vSwitch</span></code>.  Schema names begin with a
letter or an underscore, followed by any number of letters, underscores, or
digits.  The <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> commands <code class="docutils literal notranslate"><span class="pre">schema-name</span></code> and
<code class="docutils literal notranslate"><span class="pre">db-name</span></code> extract the schema name from a schema or database
file, respectively.</p>
<p>An OVSDB schema also has a version of the form <code class="docutils literal notranslate"><span class="pre">x.y.z</span></code> e.g. <code class="docutils literal notranslate"><span class="pre">1.2.3</span></code>.
Schemas managed within the Open vSwitch project manage version numbering in the
following way (but OVSDB does not mandate this approach).  Whenever we change
the database schema in a non-backward compatible way (e.g. when we delete a
column or a table), we increment &lt;x&gt; and set &lt;y&gt; and &lt;z&gt; to 0.  When we change
the database schema in a backward compatible way (e.g. when we add a new
column), we increment &lt;y&gt; and set &lt;z&gt; to 0.  When we change the database schema
cosmetically (e.g. we reindent its syntax), we increment &lt;z&gt;.  The
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> commands <code class="docutils literal notranslate"><span class="pre">schema-version</span></code> and <code class="docutils literal notranslate"><span class="pre">db-version</span></code> extract the
schema version from a schema or database file, respectively.</p>
<p>Very old OVSDB schemas do not have a version, but RFC 7047 mandates it.</p>
<p>An OVSDB schema optionally has a “checksum.”  RFC 7047 does not specify the use
of the checksum and recommends that clients ignore it.  Open vSwitch uses the
checksum to remind developers to update the version: at build time, if the
schema’s embedded checksum, ignoring the checksum field itself, does not match
the schema’s content, then it fails the build with a recommendation to update
the version and the checksum.  Thus, a developer who changes the schema, but
does not update the version, receives an automatic reminder.  In practice this
has been an effective way to ensure compliance with the version number policy.
The <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> commands <code class="docutils literal notranslate"><span class="pre">schema-cksum</span></code> and <code class="docutils literal notranslate"><span class="pre">db-cksum</span></code> extract the
schema checksum from a schema or database file, respectively.</p>
</div>
<div class="section" id="service-models">
<h2>Service Models<a class="headerlink" href="#service-models" title="Permalink to this headline">¶</a></h2>
<p>OVSDB supports three service models for databases: <strong>standalone</strong>,
<strong>active-backup</strong>, and <strong>clustered</strong>.  The service models provide different
compromises among consistency, availability, and partition tolerance.  They
also differ in the number of servers required and in terms of performance.  The
standalone and active-backup database service models share one on-disk format,
and clustered databases use a different format, but the OVSDB programs work
with both formats.  <code class="docutils literal notranslate"><span class="pre">ovsdb(5)</span></code> documents these file formats.</p>
<p>RFC 7047, which specifies the OVSDB protocol, does not mandate or specify
any particular service model.</p>
<p>The following sections describe the individual service models.</p>
<div class="section" id="standalone-database-service-model">
<h3>Standalone Database Service Model<a class="headerlink" href="#standalone-database-service-model" title="Permalink to this headline">¶</a></h3>
<p>A <strong>standalone</strong> database runs a single server.  If the server stops running,
the database becomes inaccessible, and if the server’s storage is lost or
corrupted, the database’s content is lost.  This service model is appropriate
when the database controls a process or activity to which it is linked via
“fate-sharing.”  For example, an OVSDB instance that controls an Open vSwitch
virtual switch daemon, <code class="docutils literal notranslate"><span class="pre">ovs-vswitchd</span></code>, is a standalone database because a
server failure would take out both the database and the virtual switch.</p>
<p>To set up a standalone database, use <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">create</span></code> to
create a database file, then run <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> to start the
database service.</p>
<p>To configure a client, such as <code class="docutils literal notranslate"><span class="pre">ovs-vswitchd</span></code> or <code class="docutils literal notranslate"><span class="pre">ovs-vsctl</span></code>, to use a
standalone database, configure the server to listen on a “connection method”
that the client can reach, then point the client to that connection method.
See <a class="reference internal" href="#connection-methods">Connection Methods</a> below for information about connection methods.</p>
</div>
<div class="section" id="active-backup-database-service-model">
<h3>Active-Backup Database Service Model<a class="headerlink" href="#active-backup-database-service-model" title="Permalink to this headline">¶</a></h3>
<p>An <strong>active-backup</strong> database runs two servers (on different hosts).  At any
given time, one of the servers is designated with the <strong>active</strong> role and the
other the <strong>backup</strong> role.  An active server behaves just like a standalone
server.  A backup server makes an OVSDB connection to the active server and
uses it to continuously replicate its content as it changes in real time.
OVSDB clients can connect to either server but only the active server allows
data modification or lock transactions.</p>
<p>Setup for an active-backup database starts from a working standalone database
service, which is initially the active server.  On another node, to set up a
backup server, create a database file with the same schema as the active
server.  The initial contents of the database file do not matter, as long as
the schema is correct, so <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">create</span></code> will work, as will copying the
database file from the active server.  Then use
<code class="docutils literal notranslate"><span class="pre">ovsdb-server</span> <span class="pre">--sync-from=&lt;active&gt;</span></code> to start the backup server, where
&lt;active&gt; is an OVSDB connection method (see <a class="reference internal" href="#connection-methods">Connection Methods</a> below) that
connects to the active server.  At that point, the backup server will fetch a
copy of the active database and keep it up-to-date until it is killed.</p>
<p>When the active server in an active-backup server pair fails, an administrator
can switch the backup server to an active role with the <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span></code> command
<code class="docutils literal notranslate"><span class="pre">ovsdb-server/disconnect-active-ovsdb-server</span></code>.  Clients then have read/write
access to the now-active server.  Of course, administrators are slow to respond
compared to software, so in practice external management software detects the
active server’s failure and changes the backup server’s role.  For example, the
“Integration Guide for Centralized Control” in the Open vSwitch documentation
describes how to use Pacemaker for this purpose in OVN.</p>
<p>Suppose an active server fails and its backup is promoted to active.  If the
failed server is revived, it must be started as a backup server.  Otherwise, if
both servers are active, then they may start out of sync, if the database
changed while the server was down, and they will continue to diverge over time.
This also happens if the software managing the database servers cannot reach
the active server and therefore switches the backup to active, but other hosts
can reach both servers.  These “split-brain” problems are unsolvable in general
for server pairs.</p>
<p>Compared to a standalone server, the active-backup service model
somewhat increases availability, at a risk of split-brain.  It adds
generally insignificant performance overhead.  On the other hand, the
clustered service model, discussed below, requires at least 3 servers
and has greater performance overhead, but it avoids the need for
external management software and eliminates the possibility of
split-brain.</p>
<p>Open vSwitch 2.6 introduced support for the active-backup service model.</p>
</div>
<div class="section" id="clustered-database-service-model">
<h3>Clustered Database Service Model<a class="headerlink" href="#clustered-database-service-model" title="Permalink to this headline">¶</a></h3>
<p>A <strong>clustered</strong> database runs across 3 or 5 or more database servers (the
<strong>cluster</strong>) on different hosts.  Servers in a cluster automatically
synchronize writes within the cluster.  A 3-server cluster can remain available
in the face of at most 1 server failure; a 5-server cluster tolerates up to 2
failures.  Clusters larger than 5 servers will also work, with every 2 added
servers allowing the cluster to tolerate 1 more failure, but write performance
decreases.  The number of servers should be odd: a 4- or 6-server cluster
cannot tolerate more failures than a 3- or 5-server cluster, respectively.</p>
<p>To set up a clustered database, first initialize it on a single node by running
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">create-cluster</span></code>, then start <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code>.  Depending on its
arguments, the <code class="docutils literal notranslate"><span class="pre">create-cluster</span></code> command can create an empty database or copy
a standalone database’s contents into the new database.</p>
<p>To configure a client, such as <code class="docutils literal notranslate"><span class="pre">ovn-controller</span></code> or <code class="docutils literal notranslate"><span class="pre">ovn-sbctl</span></code>, to use a
clustered database, first configure all of the servers to listen on a
connection method that the client can reach, then point the client to all of
the servers’ connection methods, comma-separated.  See <a class="reference internal" href="#connection-methods">Connection Methods</a>,
below, for more detail.</p>
<p>Open vSwitch 2.9 introduced support for the clustered service model.</p>
<div class="section" id="how-to-maintain-a-clustered-database">
<h4>How to Maintain a Clustered Database<a class="headerlink" href="#how-to-maintain-a-clustered-database" title="Permalink to this headline">¶</a></h4>
<p>To add a server to a cluster, run <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">join-cluster</span></code> on the new server
and start <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code>.  To remove a running server from a cluster, use
<code class="docutils literal notranslate"><span class="pre">ovs-appctl</span></code> to invoke the <code class="docutils literal notranslate"><span class="pre">cluster/leave</span></code> command.  When a server fails
and cannot be recovered, e.g. because its hard disk crashed, or to otherwise
remove a server that is down from a cluster, use <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span></code> to invoke
<code class="docutils literal notranslate"><span class="pre">cluster/kick</span></code> to make the remaining servers kick it out of the cluster.</p>
<p>The above methods for adding and removing servers only work for healthy
clusters, that is, for clusters with no more failures than their maximum
tolerance.  For example, in a 3-server cluster, the failure of 2 servers
prevents servers joining or leaving the cluster (as well as database access).
To prevent data loss or inconsistency, the preferred solution to this problem
is to bring up enough of the failed servers to make the cluster healthy again,
then if necessary remove any remaining failed servers and add new ones.  If
this cannot be done, though, use <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span></code> to invoke <code class="docutils literal notranslate"><span class="pre">cluster/leave</span>
<span class="pre">--force</span></code> on a running server.  This command forces the server to which it is
directed to leave its cluster and form a new single-node cluster that contains
only itself.  The data in the new cluster may be inconsistent with the former
cluster: transactions not yet replicated to the server will be lost, and
transactions not yet applied to the cluster may be committed.  Afterward, any
servers in its former cluster will regard the server to have failed.</p>
<p>The servers in a cluster synchronize data over a cluster management protocol
that is specific to Open vSwitch; it is not the same as the OVSDB protocol
specified in RFC 7047.  For this purpose, a server in a cluster is tied to a
particular IP address and TCP port, which is specified in the <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code>
command that creates or joins the cluster.  The TCP port used for clustering
must be different from that used for OVSDB clients.  To change the port or
address of a server in a cluster, first remove it from the cluster, then add it
back with the new address.</p>
<p>To upgrade the <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> processes in a cluster from one version of Open
vSwitch to another, upgrading them one at a time will keep the cluster healthy
during the upgrade process.  (This is different from upgrading a database
schema, which is covered later under <a class="reference internal" href="#upgrading-or-downgrading-a-database">Upgrading or Downgrading a Database</a>.)</p>
<p>Clustered OVSDB does not support the OVSDB “ephemeral columns” feature.
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> and <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span></code> change ephemeral columns into persistent
ones when they work with schemas for clustered databases.  Future versions of
OVSDB might add support for this feature.</p>
</div>
<div class="section" id="understanding-cluster-consistency">
<h4>Understanding Cluster Consistency<a class="headerlink" href="#understanding-cluster-consistency" title="Permalink to this headline">¶</a></h4>
<p>To ensure consistency, clustered OVSDB uses the Raft algorithm described in
Diego Ongaro’s Ph.D. thesis, “Consensus: Bridging Theory and Practice”.  In an
operational Raft cluster, at any given time a single server is the “leader” and
the other nodes are “followers”.  Only the leader processes transactions, but a
transaction is only committed when a majority of the servers confirm to the
leader that they have written it to persistent storage.</p>
<p>In most database systems, read and write access to the database happens through
transactions.  In such a system, Raft allows a cluster to present a strongly
consistent transactional interface.  OVSDB uses conventional transactions for
writes, but clients often effectively do reads a different way, by asking the
server to “monitor” a database or a subset of one on the client’s behalf.
Whenever monitored data changes, the server automatically tells the client what
changed, which allows the client to maintain an accurate snapshot of the
database in its memory.  Of course, at any given time, the snapshot may be
somewhat dated since some of it could have changed without the change
notification yet being received and processed by the client.</p>
<p>Given this unconventional usage model, OVSDB also adopts an unconventional
clustering model.  Each server in a cluster acts independently for the purpose
of monitors and read-only transactions, without verifying that data is
up-to-date with the leader.  Servers forward transactions that write to the
database to the leader for execution, ensuring consistency.  This has the
following consequences:</p>
<ul>
<li><p class="first">Transactions that involve writes, against any server in the cluster, are
linearizable if clients take care to use correct prerequisites, which is the
same condition required for linearizability in a standalone OVSDB.
(Actually, “at-least-once” consistency, because OVSDB does not have a session
mechanism to drop duplicate transactions if a connection drops after the
server commits it but before the client receives the result.)</p>
</li>
<li><p class="first">Read-only transactions can yield results based on a stale version of the
database, if they are executed against a follower.  Transactions on the
leader always yield fresh results.  (With monitors, as explained above, a
client can always see stale data even without clustering, so clustering does
not change the consistency model for monitors.)</p>
</li>
<li><p class="first">Monitor-based (or read-heavy) workloads scale well across a cluster, because
clustering OVSDB adds no additional work or communication for reads and
monitors.</p>
</li>
<li><p class="first">A write-heavy client should connect to the leader, to avoid the overhead of
followers forwarding transactions to the leader.</p>
</li>
<li><p class="first">When a client conducts a mix of read and write transactions across more than
one server in a cluster, it can see inconsistent results because a read
transaction might read stale data whose updates have not yet propagated from
the leader.  By default, <code class="docutils literal notranslate"><span class="pre">ovn-sbctl</span></code> and similar utilities connect to the
cluster leader to avoid this issue.</p>
<p>The same might occur for transactions against a single follower except that
the OVSDB server ensures that the results of a write forwarded to the leader
by a given server are visible at that server before it replies to the
requesting client.</p>
</li>
<li><p class="first">If a client uses a database on one server in a cluster, then another server
in the cluster (perhaps because the first server failed), the client could
observe stale data.  Clustered OVSDB clients, however, can use a column in
the <code class="docutils literal notranslate"><span class="pre">_Server</span></code> database to detect that data on a server is older than data
that the client previously read.  The OVSDB client library in Open vSwitch
uses this feature to avoid servers with stale data.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="database-replication">
<h2>Database Replication<a class="headerlink" href="#database-replication" title="Permalink to this headline">¶</a></h2>
<p>OVSDB can layer <strong>replication</strong> on top of any of its service models.
Replication, in this context, means to make, and keep up-to-date, a read-only
copy of the contents of a database (the <code class="docutils literal notranslate"><span class="pre">replica</span></code>).  One use of replication
is to keep an up-to-date backup of a database.  A replica used solely for
backup would not need to support clients of its own.  A set of replicas that do
serve clients could be used to scale out read access to the primary database.</p>
<p>A database replica is set up in the same way as a backup server in an
active-backup pair, with the difference that the replica is never promoted to
an active role.</p>
<p>A database can have multiple replicas.</p>
<p>Open vSwitch 2.6 introduced support for database replication.</p>
</div>
<div class="section" id="connection-methods">
<h2>Connection Methods<a class="headerlink" href="#connection-methods" title="Permalink to this headline">¶</a></h2>
<p>An OVSDB <strong>connection method</strong> is a string that specifies how to make a
JSON-RPC connection between an OVSDB client and server.  Connection methods are
part of the Open vSwitch implementation of OVSDB and not specified by RFC 7047.
<code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> uses connection methods to specify how it should listen for
connections from clients and <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span></code> uses them to specify how it
should connect to a server.  Connections in the opposite direction, where
<code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> connects to a client that is configured to listen for an
incoming connection, are also possible.</p>
<p>Connection methods are classified as <strong>active</strong> or <strong>passive</strong>.  An active
connection method makes an outgoing connection to a remote host; a passive
connection method listens for connections from remote hosts.  The most common
arrangement is to configure an OVSDB server with passive connection methods and
clients with active ones, but the OVSDB implementation in Open vSwitch supports
the opposite arrangement as well.</p>
<p>OVSDB supports the following active connection methods:</p>
<dl class="docutils">
<dt>ssl:&lt;ip&gt;:&lt;port&gt;</dt>
<dd>The specified SSL or TLS &lt;port&gt; on the host at the given &lt;ip&gt;.</dd>
<dt>tcp:&lt;ip&gt;:&lt;port&gt;</dt>
<dd>The specified TCP &lt;port&gt; on the host at the given &lt;ip&gt;.</dd>
<dt>unix:&lt;file&gt;</dt>
<dd><p class="first">On Unix-like systems, connect to the Unix domain server socket named
&lt;file&gt;.</p>
<p class="last">On Windows, connect to a local named pipe that is represented by a file
created in the path &lt;file&gt; to mimic the behavior of a Unix domain socket.</p>
</dd>
<dt>&lt;method1&gt;,&lt;method2&gt;,…,&lt;methodN&gt;</dt>
<dd><p class="first">For a clustered database service to be highly available, a client must be
able to connect to any of the servers in the cluster.  To do so, specify
connection methods for each of the servers separated by commas (and
optional spaces).</p>
<p class="last">In theory, if machines go up and down and IP addresses change in the right
way, a client could talk to the wrong instance of a database.  To avoid
this possibility, add <code class="docutils literal notranslate"><span class="pre">cid:&lt;uuid&gt;</span></code> to the list of methods, where &lt;uuid&gt;
is the cluster ID of the desired database cluster, as printed by
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">get-cid</span></code>.  This feature is optional.</p>
</dd>
</dl>
<p>OVSDB supports the following passive connection methods:</p>
<dl class="docutils">
<dt>pssl:&lt;port&gt;[:&lt;ip&gt;]</dt>
<dd>Listen on the given TCP &lt;port&gt; for SSL or TLS connections.  By default,
connections are not bound to a particular local IP address.  Specifying
&lt;ip&gt; limits connections to those from the given IP.</dd>
<dt>ptcp:&lt;port&gt;[:&lt;ip&gt;]</dt>
<dd>Listen on the given TCP &lt;port&gt;.  By default, connections are not bound to a
particular local IP address.  Specifying &lt;ip&gt; limits connections to those
from the given IP.</dd>
<dt>punix:&lt;file&gt;</dt>
<dd><p class="first">On Unix-like systems, listens for connections on the Unix domain socket
named &lt;file&gt;.</p>
<p class="last">On Windows, listens on a local named pipe, creating a named pipe
&lt;file&gt; to mimic the behavior of a Unix domain socket.</p>
</dd>
</dl>
<p>All IP-based connection methods accept IPv4 and IPv6 addresses.  To specify an
IPv6 address, wrap it in square brackets, e.g.  <code class="docutils literal notranslate"><span class="pre">ssl:[::1]:6640</span></code>.  Passive
IP-based connection methods by default listen for IPv4 connections only; use
<code class="docutils literal notranslate"><span class="pre">[::]</span></code> as the address to accept both IPv4 and IPv6 connections,
e.g. <code class="docutils literal notranslate"><span class="pre">pssl:6640:[::]</span></code>.  DNS names are not accepted.  On Linux, use
<code class="docutils literal notranslate"><span class="pre">%&lt;device&gt;</span></code> to designate a scope for IPv6 link-level addresses,
e.g. <code class="docutils literal notranslate"><span class="pre">ssl:[fe80::1234%eth0]:6653</span></code>.</p>
<p>The &lt;port&gt; may be omitted from connection methods that use a port number.  The
default &lt;port&gt; for TCP-based connection methods is 6640, e.g. <code class="docutils literal notranslate"><span class="pre">pssl:</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">pssl:6640</span></code>.  In Open vSwitch prior to version 2.4.0, the
default port was 6632.  To avoid incompatibility between older and newer
versions, we encourage users to specify a port number.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ssl</span></code> and <code class="docutils literal notranslate"><span class="pre">pssl</span></code> connection methods requires additional configuration
through <code class="docutils literal notranslate"><span class="pre">--private-key</span></code>, <code class="docutils literal notranslate"><span class="pre">--certificate</span></code>, and <code class="docutils literal notranslate"><span class="pre">--ca-cert</span></code> command line
options.  Open vSwitch can be built without SSL support, in which case these
connection methods are not supported.</p>
</div>
<div class="section" id="database-life-cycle">
<h2>Database Life Cycle<a class="headerlink" href="#database-life-cycle" title="Permalink to this headline">¶</a></h2>
<p>This section describes how to handle various events in the life cycle of
a database using the Open vSwitch implementation of OVSDB.</p>
<div class="section" id="creating-a-database">
<h3>Creating a Database<a class="headerlink" href="#creating-a-database" title="Permalink to this headline">¶</a></h3>
<p>Creating and starting up the service for a new database was covered
separately for each database service model in the <a class="reference internal" href="#service-models">Service
Models</a> section, above.</p>
</div>
<div class="section" id="backing-up-and-restoring-a-database">
<h3>Backing Up and Restoring a Database<a class="headerlink" href="#backing-up-and-restoring-a-database" title="Permalink to this headline">¶</a></h3>
<p>OVSDB is often used in contexts where the database contents are not
particularly valuable.  For example, in many systems, the database for
configuring <code class="docutils literal notranslate"><span class="pre">ovs-vswitchd</span></code> is essentially rebuilt from scratch
at boot time.  It is not worthwhile to back up these databases.</p>
<p>When OVSDB is used for valuable data, a backup strategy is worth
considering.  One way is to use database replication, discussed above in
<a class="reference internal" href="#database-replication">Database Replication</a> which keeps an online, up-to-date
copy of a database, possibly on a remote system.  This works with all OVSDB
service models.</p>
<p>A more common backup strategy is to periodically take and store a snapshot.
For the standalone and active-backup service models, making a copy of the
database file, e.g. using <code class="docutils literal notranslate"><span class="pre">cp</span></code>, effectively makes a snapshot, and because
OVSDB database files are append-only, it works even if the database is being
modified when the snapshot takes place.  This approach does not work for
clustered databases.</p>
<p>Another way to make a backup, which works with all OVSDB service models, is to
use <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span> <span class="pre">backup</span></code>, which connects to a running database server and
outputs an atomic snapshot of its schema and content, in the same format used
for standalone and active-backup databases.</p>
<p>Multiple options are also available when the time comes to restore a database
from a backup.  For the standalone and active-backup service models, one option
is to stop the database server or servers, overwrite the database file with the
backup (e.g. with <code class="docutils literal notranslate"><span class="pre">cp</span></code>), and then restart the servers.  Another way, which
works with any service model, is to use <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span> <span class="pre">restore</span></code>, which
connects to a running database server and replaces the data in one of its
databases by a provided snapshot.  The advantage of <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span> <span class="pre">restore</span></code> is
that it causes zero downtime for the database and its server.  It has the
downside that UUIDs of rows in the restored database will differ from those in
the snapshot, because the OVSDB protocol does not allow clients to specify row
UUIDs.</p>
<p>None of these approaches saves and restores data in columns that the schema
designates as ephemeral.  This is by design: the designer of a schema only
marks a column as ephemeral if it is acceptable for its data to be lost
when a database server restarts.</p>
<p>Clustering and backup serve different purposes.  Clustering increases
availability, but it does not protect against data loss if, for example, a
malicious or malfunctioning OVSDB client deletes or tampers with data.</p>
</div>
<div class="section" id="changing-database-service-model">
<h3>Changing Database Service Model<a class="headerlink" href="#changing-database-service-model" title="Permalink to this headline">¶</a></h3>
<p>Use <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">create-cluster</span></code> to create a clustered database from the
contents of a standalone database.  Use <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">backup</span></code> to create a
standalone database from the contents of a clustered database.</p>
</div>
<div class="section" id="upgrading-or-downgrading-a-database">
<h3>Upgrading or Downgrading a Database<a class="headerlink" href="#upgrading-or-downgrading-a-database" title="Permalink to this headline">¶</a></h3>
<p>The evolution of a piece of software can require changes to the schemas of the
databases that it uses.  For example, new features might require new tables or
new columns in existing tables, or conceptual changes might require a database
to be reorganized in other ways.  In some cases, the easiest way to deal with a
change in a database schema is to delete the existing database and start fresh
with the new schema, especially if the data in the database is easy to
reconstruct.  But in many other cases, it is better to convert the database
from one schema to another.</p>
<p>The OVSDB implementation in Open vSwitch has built-in support for some simple
cases of converting a database from one schema to another.  This support can
handle changes that add or remove database columns or tables or that eliminate
constraints (for example, changing a column that must have exactly one value
into one that has one or more values).  It can also handle changes that add
constraints or make them stricter, but only if the existing data in the
database satisfies the new constraints (for example, changing a column that has
one or more values into a column with exactly one value, if every row in the
column has exactly one value).  The built-in conversion can cause data loss in
obvious ways, for example if the new schema removes tables or columns, or
indirectly, for example by deleting unreferenced rows in tables that the new
schema marks for garbage collection.</p>
<p>Converting a database can lose data, so it is wise to make a backup beforehand.</p>
<p>To use OVSDB’s built-in support for schema conversion with a standalone or
active-backup database, first stop the database server or servers, then use
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">convert</span></code> to convert it to the new schema, and then restart the
database server.</p>
<p>OVSDB also supports online database schema conversion for any of its database
service models.  To convert a database online, use <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span> <span class="pre">convert</span></code>.
The conversion is atomic, consistent, isolated, and durable.  <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code>
disconnects any clients connected when the conversion takes place (except
clients that use the <code class="docutils literal notranslate"><span class="pre">set_db_change_aware</span></code> Open vSwitch extension RPC).  Upon
reconnection, clients will discover that the schema has changed.</p>
<p>Schema versions and checksums (see <a class="reference internal" href="#schemas">Schemas</a> above) can give hints about whether
a database needs to be converted to a new schema.  If there is any question,
though, the <code class="docutils literal notranslate"><span class="pre">needs-conversion</span></code> command on <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> and <code class="docutils literal notranslate"><span class="pre">ovsdb-client</span></code>
can provide a definitive answer.</p>
</div>
<div class="section" id="working-with-database-history">
<h3>Working with Database History<a class="headerlink" href="#working-with-database-history" title="Permalink to this headline">¶</a></h3>
<p>Both on-disk database formats that OVSDB supports are organized as a stream of
transaction records.  Each record describes a change to the database as a list
of rows that were inserted or deleted or modified, along with the details.
Therefore, in normal operation, a database file only grows, as each change
causes another record to be appended at the end.  Usually, a user has no need
to understand this file structure.  This section covers some exceptions.</p>
</div>
<div class="section" id="compacting-databases">
<h3>Compacting Databases<a class="headerlink" href="#compacting-databases" title="Permalink to this headline">¶</a></h3>
<p>If OVSDB database files were truly append-only, then over time they would grow
without bound.  To avoid this problem, OVSDB can <strong>compact</strong> a database file,
that is, replace it by a new version that contains only the current database
contents, as if it had been inserted by a single transaction.  From time to
time, <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> automatically compacts a database that grows much larger
than its minimum size.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> automatically compacts databases, it is usually not
necessary to compact them manually, but OVSDB still offers a few ways to do it.
First, <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">compact</span></code> can compact a standalone or active-backup
database that is not currently being served by <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> (or otherwise
locked for writing by another process).  To compact any database that is
currently being served by <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code>, use <code class="docutils literal notranslate"><span class="pre">ovs-appctl</span></code> to send the
<code class="docutils literal notranslate"><span class="pre">ovsdb-server/compact</span></code> command.  Each server in an active-backup or clustered
database maintains its database file independently, so to compact all of them,
issue this command separately on each server.</p>
</div>
<div class="section" id="viewing-history">
<h3>Viewing History<a class="headerlink" href="#viewing-history" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span></code> utility’s <code class="docutils literal notranslate"><span class="pre">show-log</span></code> command displays the transaction
records in an OVSDB database file in a human-readable format.  By default, it
shows minimal detail, but adding the option <code class="docutils literal notranslate"><span class="pre">-m</span></code> once or twice increases the
level of detail.  In addition to the transaction data, it shows the time and
date of each transaction and any “comment” added to the transaction by the
client.  The comments can be helpful for quickly understanding a transaction;
for example, <code class="docutils literal notranslate"><span class="pre">ovs-vsctl</span></code> adds its command line to the transactions that it
makes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">show-log</span></code> command works with both OVSDB file formats, but the details of
the output format differ.  For active-backup and clustered databases, the
sequence of transactions in each server’s log will differ, even at points when
they reflect the same data.</p>
</div>
<div class="section" id="truncating-history">
<h3>Truncating History<a class="headerlink" href="#truncating-history" title="Permalink to this headline">¶</a></h3>
<p>It may occasionally be useful to “roll back” a database file to an earlier
point.  Because of the organization of OVSDB records, this is easy to do.
Start by noting the record number &lt;i&gt; of the first record to delete in
<code class="docutils literal notranslate"><span class="pre">ovsdb-tool</span> <span class="pre">show-log</span></code> output.  Each record is two lines of plain text, so
trimming the log is as simple as running <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">-n</span> <span class="pre">&lt;j&gt;</span></code>, where &lt;j&gt; = 2 * &lt;i&gt;.</p>
</div>
<div class="section" id="corruption">
<h3>Corruption<a class="headerlink" href="#corruption" title="Permalink to this headline">¶</a></h3>
<p>When <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> opens an OVSDB database file, of any kind, it reads as
many transaction records as it can from the file until it reaches the end of
the file or it encounters a corrupted record.  At that point it stops reading
and regards the data that it has read to this point as the full contents of the
database file, effectively rolling the database back to an earlier point.</p>
<p>Each transaction record contains an embedded SHA-1 checksum, which the server
verifies as it reads a database file.  It detects corruption when a checksum
fails to verify.  Even though SHA-1 is no longer considered secure for use in
cryptography, it is acceptable for this purpose because it is not used to
defend against malicious attackers.</p>
<p>The first record in a standalone or active-backup database file specifies the
schema.  <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> will refuse to work with a database where this record
is corrupted, or with a clustered database file with corruption in the first
few records.  Delete and recreate such a database, or restore it from a backup.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">ovsdb-server</span></code> adds records to a database file in which it detected
corruption, it first truncates the file just after the last good record.</p>
</div>
</div>
<div class="section" id="see-also">
<h2>See Also<a class="headerlink" href="#see-also" title="Permalink to this headline">¶</a></h2>
<p>RFC 7047, “The Open vSwitch Database Management Protocol.”</p>
<p>Open vSwitch implementations of generic OVSDB functionality:
<code class="docutils literal notranslate"><span class="pre">ovsdb-server(1)</span></code>, <code class="docutils literal notranslate"><span class="pre">ovsdb-client(1)</span></code>, <code class="docutils literal notranslate"><span class="pre">ovsdb-tool(1)</span></code>.</p>
<p>Tools for working with databases that have specific OVSDB schemas:
<code class="docutils literal notranslate"><span class="pre">ovs-vsctl(8)</span></code>, <code class="docutils literal notranslate"><span class="pre">vtep-ctl(8)</span></code>, <code class="docutils literal notranslate"><span class="pre">ovn-nbctl(8)</span></code>, <code class="docutils literal notranslate"><span class="pre">ovn-sbctl(8)</span></code>.</p>
<p>OVSDB schemas for Open vSwitch and related functionality:
<code class="docutils literal notranslate"><span class="pre">ovs-vswitchd.conf.db(5)</span></code>, <code class="docutils literal notranslate"><span class="pre">vtep(5)</span></code>, <code class="docutils literal notranslate"><span class="pre">ovn-nb(5)</span></code>, <code class="docutils literal notranslate"><span class="pre">ovn-sb(5)</span></code>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ovsdb</a><ul>
<li><a class="reference internal" href="#description">Description</a></li>
<li><a class="reference internal" href="#schemas">Schemas</a></li>
<li><a class="reference internal" href="#service-models">Service Models</a><ul>
<li><a class="reference internal" href="#standalone-database-service-model">Standalone Database Service Model</a></li>
<li><a class="reference internal" href="#active-backup-database-service-model">Active-Backup Database Service Model</a></li>
<li><a class="reference internal" href="#clustered-database-service-model">Clustered Database Service Model</a><ul>
<li><a class="reference internal" href="#how-to-maintain-a-clustered-database">How to Maintain a Clustered Database</a></li>
<li><a class="reference internal" href="#understanding-cluster-consistency">Understanding Cluster Consistency</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#database-replication">Database Replication</a></li>
<li><a class="reference internal" href="#connection-methods">Connection Methods</a></li>
<li><a class="reference internal" href="#database-life-cycle">Database Life Cycle</a><ul>
<li><a class="reference internal" href="#creating-a-database">Creating a Database</a></li>
<li><a class="reference internal" href="#backing-up-and-restoring-a-database">Backing Up and Restoring a Database</a></li>
<li><a class="reference internal" href="#changing-database-service-model">Changing Database Service Model</a></li>
<li><a class="reference internal" href="#upgrading-or-downgrading-a-database">Upgrading or Downgrading a Database</a></li>
<li><a class="reference internal" href="#working-with-database-history">Working with Database History</a></li>
<li><a class="reference internal" href="#compacting-databases">Compacting Databases</a></li>
<li><a class="reference internal" href="#viewing-history">Viewing History</a></li>
<li><a class="reference internal" href="#truncating-history">Truncating History</a></li>
<li><a class="reference internal" href="#corruption">Corruption</a></li>
</ul>
</li>
<li><a class="reference internal" href="#see-also">See Also</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">Reference Guide</a><ul>
      <li>Previous: <a href="ovsdb.5.html" title="previous chapter">ovsdb</a></li>
      <li>Next: <a href="../faq/index.html" title="next chapter">Open vSwitch FAQ</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/ref/ovsdb.7.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, The Open vSwitch Development Community.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/ref/ovsdb.7.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>